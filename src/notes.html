<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The Political Landscape of Bremen, A Data Science Approach</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="notes_files/libs/clipboard/clipboard.min.js"></script>
<script src="notes_files/libs/quarto-html/quarto.js"></script>
<script src="notes_files/libs/quarto-html/popper.min.js"></script>
<script src="notes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="notes_files/libs/quarto-html/anchor.min.js"></script>
<link href="notes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="notes_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="notes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="notes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="notes_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract"><span class="toc-section-number">1</span>  Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="toc-section-number">2</span>  Introduction</a>
  <ul class="collapse">
  <li><a href="#background-and-motivation" id="toc-background-and-motivation" class="nav-link" data-scroll-target="#background-and-motivation"><span class="toc-section-number">2.1</span>  Background and Motivation</a></li>
  <li><a href="#research-question" id="toc-research-question" class="nav-link" data-scroll-target="#research-question"><span class="toc-section-number">2.2</span>  Research Question</a></li>
  <li><a href="#literature-review" id="toc-literature-review" class="nav-link" data-scroll-target="#literature-review"><span class="toc-section-number">2.3</span>  Literature Review</a></li>
  </ul></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology"><span class="toc-section-number">3</span>  Methodology</a>
  <ul class="collapse">
  <li><a href="#data-collection-processing" id="toc-data-collection-processing" class="nav-link" data-scroll-target="#data-collection-processing"><span class="toc-section-number">3.1</span>  Data Collection &amp; processing</a></li>
  <li><a href="#the-five-vote-system-in-germany" id="toc-the-five-vote-system-in-germany" class="nav-link" data-scroll-target="#the-five-vote-system-in-germany"><span class="toc-section-number">3.2</span>  The Five-Vote System in Germany</a></li>
  <li><a href="#data-preprocessing" id="toc-data-preprocessing" class="nav-link" data-scroll-target="#data-preprocessing"><span class="toc-section-number">3.3</span>  Data Preprocessing</a></li>
  <li><a href="#techniques" id="toc-techniques" class="nav-link" data-scroll-target="#techniques"><span class="toc-section-number">3.4</span>  Techniques</a></li>
  <li><a href="#dimensionality-reduction" id="toc-dimensionality-reduction" class="nav-link" data-scroll-target="#dimensionality-reduction"><span class="toc-section-number">3.5</span>  Dimensionality Reduction</a></li>
  <li><a href="#muti-dimensional-scaling" id="toc-muti-dimensional-scaling" class="nav-link" data-scroll-target="#muti-dimensional-scaling"><span class="toc-section-number">3.6</span>  Muti Dimensional Scaling</a></li>
  <li><a href="#tsne" id="toc-tsne" class="nav-link" data-scroll-target="#tsne"><span class="toc-section-number">3.7</span>  TSNE</a></li>
  </ul></li>
  <li><a href="#discusion" id="toc-discusion" class="nav-link" data-scroll-target="#discusion"><span class="toc-section-number">4</span>  Discusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="toc-section-number">5</span>  REFERENCES</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">The Political Landscape of Bremen, A Data Science Approach</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="abstract" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Abstract</h1>
<p>The objective of this master’s thesis is to conduct a thorough and systematic analysis of political party preferences in Bremen across the last four electoral cycles, employing advanced data science methods. The study captures and visualizes the correlations between political parties based on voting data using dimensionality reduction techniques such as Principal Component Analysis (PCA), Multidimensional Scaling (MDS), and t-Distributed Stochastic Neighbor Embedding (t-SNE). The datasets for these models were generated using two different methods: the first builds a matrix from the percentages of co-voters for each pair of political parties, and the second computes the ratio of the union to the intersection of co-voters. These approaches provide a comprehensive view of voter base overlaps and the relative breadth of party support. The application of PCA, MDS, and t-SNE to these datasets reveals underlying patterns and shifts in political alignment among voters. The findings of this study offer novel and significant insights into the development and transformation of the political landscape in Bremen, highlighting trends and relationships that may not be apparent through traditional analysis methods.</p>
</section>
<section id="introduction" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Introduction</h1>
<section id="background-and-motivation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="background-and-motivation"><span class="header-section-number">2.1</span> Background and Motivation</h2>
<p>Bremen is a city-state in Germany with a long and rich history of political participation and diversity. It is the smallest and oldest of the 16 federal states, with a population of about 680,000 and an area of 419 km². It consists of two major cities, Bremen and Bremerhaven, which are separated by 60 km of Lower Saxony. Bremen is known for its maritime economy, cultural heritage, and cosmopolitan outlook, while Bremerhaven is a major port and a center of scientific research.</p>
<p>The political landscape of Bremen reflects its unique and dynamic character. It has been a stronghold of the Social Democratic Party (SPD), a center-left party, since 1946. The SPD has historically been influential in shaping the state’s policies and governance. On the left of the political spectrum, Bremen has also seen the presence of the Left Party (Die Linke), representing far-left ideologies and advocating for more radical changes in social and economic policies.On the right of the spectrum, the Christian Democratic Union (CDU) has been a significant political force, representing center-right to right-wing views with a focus on conservative values and market-oriented policies. The Free Democratic Party (FDP), which also aligns with center-right ideologies, advocates for economic liberalism and individual freedoms.</p>
<p>In recent years, the political landscape has become more fragmented with the rise of new parties. The Green Party (Die Grünen), positioned on the left, emphasizes environmental issues, social justice, and sustainable development. On the far-right, the Alternative for Germany (AfD) has gained prominence, advocating for nationalist and anti-immigration policies. The Citizens in Rage (BiW) is another right-wing party that has emerged, often focusing on local issues and expressing populist sentiments.</p>
<p>Elections in Bremen, like in other historic cities, are influenced by various factors such as economic conditions, social issues, media coverage, and voter turnout. The results of these elections have significant implications for governance, policies, and representation at the state level, as well as for Bremen’s relations with the federal government and other states.</p>
<p>The motivation for this study stems from a desire to extend the use of data science and machine learning beyond their traditional applications in pure sciences, exploring their potential in the social sciences. Analyzing the political landscape using advanced data science techniques offers an intriguing opportunity to gain new insights into voter behavior and party dynamics. By applying methods such as <em>Principal Component Analysis (PCA)</em>, <em>Multidimensional Scaling (MDS)</em>, and <em>t-Distributed Stochastic Neighbor Embedding (t-SNE)</em> to the Bremen election data, this study aims to uncover patterns and allign parties in a two dimensional scalling</p>
<p>This study will employ dimensionality reduction techniques to create visual representations of political party relationships based on voter data. The datasets for these models are constructed using two approaches: one based on the percentages of co-voters for each pair of political parties, and the other on the ratio of the union to the intersection of co-voters. These methods provide a nuanced view of voter base overlaps and the relative breadth of party support.</p>
<p>The results of this analysis are expected to contribute valuable insights into the evolving political landscape of Bremen, highlighting trends and relationships that could inform future electoral strategies and political understanding. By venturing into the realm of social science through the lens of data science, this study aims to demonstrate the versatility and applicability of machine learning techniques in understanding complex societal phenomena.</p>
</section>
<section id="research-question" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="research-question"><span class="header-section-number">2.2</span> Research Question</h2>
<ul>
<li>How have the voting patterns for political parties in Bremen evolved over the past four electoral cycles?</li>
<li>How much is the voter trend changing in Bremen over the last four (4) elections and what doe this signify for Bremen as a state?</li>
<li>Can dimensionality reduction techniques (PCA, MDS, and T-SNE) reveal any significant shifts or trends in the political landscape of Bremen?</li>
</ul>
<section id="significance-of-the-studies" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="significance-of-the-studies"><span class="header-section-number">2.2.1</span> Significance of the studies</h3>
<p>Understanding the political landscape of Bremen through a data science lens holds immense significance for various reasons. Firstly, this study has the potential to unveil the intricate changes in voters’ preferences and behaviors over time. By employing advanced data science techniques, such as Principal Component Analysis (PCA), Multidimensional Scaling (MDS), and t-Distributed Stochastic Neighbor Embedding (t-SNE), the analysis can identify patterns and trends in voting behavior, shedding light on the factors that have influenced these shifts. Unraveling the dynamics of voter preferences is crucial for fostering a deeper comprehension of the democratic processes within the region.</p>
<p>Secondly, the study aims to explore how political parties in Bremen, spanning the political spectrum from the far-left (Die Linke) to the far-right (AfD), as well as center-left (SPD) and center-right (CDU, FDP) parties, have adapted their strategies and policies in response to the evolving electoral landscape. Investigating the challenges faced by these political entities allows for a nuanced understanding of the strategies that proved successful and those that were less effective. This knowledge can be instrumental for both political practitioners and researchers, providing insights into the adaptive capabilities of political organizations in a dynamic environment.</p>
<p>Moreover, the study will consider the size and influence of these parties. By analyzing large, established parties like the SPD and CDU alongside smaller or emerging parties like the Greens, AfD, and BiW, the research can highlight differences in their voter bases, policy impacts, and strategic adaptations. This comprehensive view contributes to a richer understanding of the political ecosystem in Bremen.</p>
<p>Furthermore, the analysis of political outcomes and their impact on governance, development, and representation in Bremen at the state and federal levels is of paramount importance. Understanding how shifts in political power translate into tangible effects on governance and development helps policymakers anticipate and respond to emerging trends. It also provides an opportunity to identify risks and opportunities associated with different political scenarios, offering valuable insights for proactive decision-making.</p>
<p>Beyond its local implications, the study significantly advances the broader literature on political analysis. The application of advanced data science techniques, including machine learning models and statistical measures, to the analysis of complex and dynamic political data is a novel contribution. By demonstrating the efficacy of these methods in a real-world political context, the study enriches the toolkit available for political scientists and data analysts alike, paving the way for innovative approaches in future research endeavors.</p>
<p>Moreover, the study enables a comparative analysis of different methods and tools for political analysis, evaluating their respective strengths and limitations. This comparative aspect is crucial for advancing the field, guiding researchers and practitioners towards the most effective approaches based on the specific nuances of their data and research questions.</p>
<p>Lastly, effective communication and dissemination of findings are vital aspects of the study. Understanding how to convey complex political insights derived from data science methodologies to diverse audiences and stakeholders ensures the practical utility of the research. The study will contribute to the development of effective communication strategies, facilitating the translation of data-driven political analyses into actionable information for policymakers, political actors, and the public. This will help bridge the gap between complex data science techniques and practical political applications, ensuring that the insights gained are accessible and impactful.</p>
</section>
</section>
<section id="literature-review" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="literature-review"><span class="header-section-number">2.3</span> Literature Review</h2>
<p>The analysis of election data has become increasingly vital in understanding the dynamics of political landscapes, voter behaviors, and party strategies.</p>
<p>Temporal analysis of election data has been a recurrent theme in the literature, with researchers employing diverse statistical techniques to unravel the changing preferences of voters over time. Studies such as (Bowler et al., 2018) and (Exploring the Political Pulse of a Country Using Data Science Tools | Journal of Computational Social Science, n.d.) have applied time series analysis to model the evolution of voter sentiment, identifying critical factors influencing shifts in electoral preferences.</p>
<p>Understanding the ramifications of election outcomes on governance, development, and representation has garnered attention in the literature. Notable studies, such as (Kellermann, 2023) delve into the practical implications of political shifts, exploring how changes in power dynamics influence policy decisions, public services, and overall governance. The integration of advanced data science techniques into political analysis represents a growing trend. Works by (Aramburo et al., 2022) showcase the application of machine learning models and statistical measures, such as sentiment analysis to discern complex patterns within election data. These studies contribute to the evolving methodology in political science research, opening avenues for more nuanced analyses.</p>
<p>Effectively communicating complex political insights derived from data science methodologies is a crucial aspect explored in the literature. Studies, such as (Exploring the Political Pulse of a Country Using Data Science Tools | Journal of Computational Social Science, n.d.), focus on developing communication strategies that bridge the gap between technical analyses and the comprehension of diverse audiences, including policymakers, political actors, and the general public.</p>
</section>
</section>
<section id="methodology" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Methodology</h1>
<section id="data-collection-processing" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="data-collection-processing"><span class="header-section-number">3.1</span> Data Collection &amp; processing</h2>
<p>In order to conduct a comprehensive study on the political landscape of Bremen, election data has been sourced directly from the Statistisches Landesamt Bremen. As the mandated legal body responsible for the management and storage of election data in Bremen, Statistisches Landesamt plays a pivotal role in ensuring the accuracy, integrity, and accessibility of electoral information. By collaborating with this authoritative institution, the study ensures access to a reliable and official dataset, providing a solid foundation for the ensuing data science analysis. The utilization of data curated and maintained by Statistisches Landesamt Bremen not only enhances the credibility of the research findings but also underscores the commitment to adhering to legal and ethical standards in acquiring and utilizing electoral data for academic purposes. This collaboration reinforces the study’s dedication to conducting rigorous and responsible research on the political dynamics of Bremen.</p>
</section>
<section id="the-five-vote-system-in-germany" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="the-five-vote-system-in-germany"><span class="header-section-number">3.2</span> The Five-Vote System in Germany</h2>
<p>In Germany, the electoral system used for federal elections is a mixed-member proportional representation system. Each voter has two votes: the first for an individual constituency candidate, and the second for a party-list in a particular state/Land (The Voting System, n.d.). Voters receive a ballot paper that allows them to cast two votes, referred to as the “first vote” (Erststimme) and the “second vote” (Zweitstimme). This system is designed to combine the benefits of direct and proportional representation. Here’s a brief overview of how the ballot works and how the data is collected. <img src="../img/Stimmzettel_HB-BB_2023.jpeg" class="img-fluid" data-fig-align="center"></p>
<section id="the-ballot-paper" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="the-ballot-paper"><span class="header-section-number">3.2.1</span> The Ballot Paper</h3>
<p>The German ballot paper is divided into two sections:</p>
<p>First Vote (Erststimme): This vote is cast for a direct candidate in the voter’s constituency. The candidate with the most votes in each constituency wins a seat in the Bundestag (Germany’s federal parliament). Each candidate is identified by a unique code. The last two digits of this code represent the candidate number, while the first two digits represent the party affiliation. Second Vote (Zweitstimme): This vote is cast for a political party. It determines the overall proportion of seats each party will receive in the Bundestag. The second vote is crucial because it decides the total representation of parties in parliament. ####</p>
<p>During the election, votes are collected and recorded with specific codes that identify both the party and the candidate. For instance:</p>
<p>First Vote (Erststimme) Data:</p>
<p>A code like 0101 might represent a candidate from Party 01 (e.g., SPD) who is candidate number 01 in that party. 0202 could represent a candidate from Party 02 (e.g., CDU) who is candidate number 02 in that party.</p>
<p>Second Vote (Zweitstimme) Data:</p>
<p>Votes are recorded for the parties based on the proportional representation system. A code like 01 would count as a vote for Party 01 (SPD). 02 would count as a vote for Party 02 (CDU).</p>
<p>The data collected from the ballots is processed to understand voting patterns and party preferences. Each vote is logged with the relevant codes, and this information is aggregated to analyze the overall electoral outcomes.</p>
<p>Consider the following data records from an election: ** 0101, 0102, 0201, 0301, 0401 **</p>
<p>These records indicate that the voters chose candidates and parties as follows:</p>
<ul>
<li>Voter 1 chose candidate 01 from Party 01 (SPD) and Party 01 (SPD) for the second vote.</li>
<li>Voter 2 chose candidate 02 from Party 01 (SPD) and Party 02 (CDU) for the second vote.</li>
<li>Voter 3 chose candidate 01 from Party 02 (CDU) and Party 03 (Greens) for the second vote.</li>
<li>Voter 4 chose candidate 01 from Party 03 (Greens) and Party 01 (SPD) for the second vote.</li>
<li>Voter 5 chose candidate 01 from Party 04 (FDP) and Party 04 (FDP) for the second vote.</li>
</ul>
<p>NB: These partyy codes like 01 for SPD are not static, the change in every election cycle based on the performance of the parties in the privous elections and some other factors.</p>
<p>This dual voting system allows for a nuanced representation of voter preferences, balancing direct candidate support with proportional party representation.</p>
</section>
</section>
<section id="data-preprocessing" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="data-preprocessing"><span class="header-section-number">3.3</span> Data Preprocessing</h2>
<p>To analyze the political landscape of Bremen using dimensionality reduction techniques such as PCA, MDS, and T-SNE, we prepared our datasets with a focus on voter behavior patterns. The raw data from the <img src="../img/stmme.png" class="img-fluid" data-fig-align="center"> The goal was to transform the raw voting data into a format suitable for these techniques, capturing the relationships between political parties in a meaningful way. Two distinct approaches were used to create our datasets, ensuring a comprehensive analysis.</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>party_codes <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Parteien-Codes.xlsx"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_unique_numbers(df):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  df <span class="op">=</span> df.astype(<span class="bu">int</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  unique_counts <span class="op">=</span> {}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> value <span class="kw">in</span> row:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> value <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>              unique_counts[value] <span class="op">=</span> unique_counts.get(value, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  unique_counts_df <span class="op">=</span> pd.DataFrame(<span class="bu">list</span>(unique_counts.items()), columns<span class="op">=</span>[<span class="st">'Number'</span>, <span class="st">'Count'</span>])</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> unique_counts_df</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_hundredth(number):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (number <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span><span class="dv">100</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">#Merged with party code</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> party_percentage_dist(df, party_codes, year, district):</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Merge with the party code</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    unique_counts_df <span class="op">=</span> count_unique_numbers(df)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    unique_counts_df[<span class="st">'party_id'</span>] <span class="op">=</span> unique_counts_df[<span class="st">'Number'</span>].<span class="bu">apply</span>(get_hundredth)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    party_votes <span class="op">=</span> unique_counts_df.groupby(<span class="st">'party_id'</span>)[<span class="st">'Count'</span>].<span class="bu">sum</span>().reset_index()</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    party_votes.columns <span class="op">=</span> [<span class="st">'party_id'</span>, <span class="st">'total_count'</span>]</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    total_votes <span class="op">=</span> party_votes[<span class="st">'total_count'</span>].<span class="bu">sum</span>()</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    party_votes[<span class="st">'percentage %'</span>] <span class="op">=</span> ((party_votes[<span class="st">'total_count'</span>] <span class="op">/</span> total_votes) <span class="op">*</span> <span class="dv">100</span>).<span class="bu">round</span>(<span class="dv">2</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    party_codes <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> year) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> district)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    merged_df <span class="op">=</span> pd.merge(party_votes, party_codes, how<span class="op">=</span><span class="st">'inner'</span>, on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">#table_party = tabulate(merged_df, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merged_df</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> pd.read_excel(<span class="st">'../Data/Stimmzettel 2011 Wahlbereich Bremen Vertrag.xlsx'</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011.iloc[<span class="dv">0</span>:]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>new_headers <span class="op">=</span> df_2011.iloc[<span class="dv">0</span>]</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>df_2011.columns <span class="op">=</span> new_headers</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span>df_2011[<span class="dv">1</span>:]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>df_2011.isnull()</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>df_2011.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>Valid_count <span class="op">=</span> df_2011[df_2011[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2011<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2011 Bremen data set of which </span><span class="sc">{</span>Valid_count<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011[df_2011[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011.drop(columns<span class="op">=</span><span class="st">"Bemerkungen"</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011.astype(<span class="bu">str</span>) </span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2011.to_pickle("../../Data/prepared_date/Bremen_2011.pkl")</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2011</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>bremen_2011_percent <span class="op">=</span> party_percentage_dist(df_2011, party_codes, year, district)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Stimmzettel 2015 Wahlbereich Bremen Vertrag.xlsx"</span>)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.iloc[<span class="dv">0</span>:]</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>new_headers <span class="op">=</span> df_2015.iloc[<span class="dv">0</span>]</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>df_2015.columns <span class="op">=</span> new_headers</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span>df_2015[<span class="dv">1</span>:]</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>df_2015.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>Valid_count_2015 <span class="op">=</span> df_2015[df_2015[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2015<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2015 data set of which </span><span class="sc">{</span>Valid_count_2015<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015[df_2015[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.drop(columns<span class="op">=</span><span class="st">"Bemerkungen"</span>) </span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.astype(<span class="bu">str</span>)</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2015.to_pickle("../../Data/prepared_date/Bremen_2015.pkl")</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2015</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>bremen_2015_percent <span class="op">=</span> party_percentage_dist(df_2015, party_codes, year, district)</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Stimmzettel 2019 Wahlbereich Bremen Vertrag.xlsx"</span>)</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>df_2019.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>Valid_count_2019 <span class="op">=</span> df_2019[df_2019[<span class="st">'Grund Ungültigkeit'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2019<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2019 data set of which </span><span class="sc">{</span>Valid_count_2019<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> df_2019[df_2019[<span class="st">'Grund Ungültigkeit'</span>] <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> df_2019.drop(columns<span class="op">=</span><span class="st">"Grund Ungültigkeit"</span>) </span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>df_2019.rename(columns<span class="op">=</span>{<span class="st">'Stimme1'</span>: <span class="st">'Stimme 1'</span>, <span class="st">'Stimme2'</span>:<span class="st">'Stimme 2'</span>, <span class="st">'Stimme3'</span>:<span class="st">'Stimme 3'</span>, <span class="st">'Stimme4'</span>:<span class="st">'Stimme 4'</span>, <span class="st">'Stimme5'</span>:<span class="st">'Stimme 5'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> df_2019.astype(<span class="bu">int</span>).astype(<span class="bu">str</span>)</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2019.to_pickle("../../Data/prepared_date/Bremen_2019.pkl")</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2019</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>bremen_2019_percent <span class="op">=</span> party_percentage_dist(df_2019, party_codes, year, district)</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Stimmzettel 2023 Wahlbereich Bremen Vertrag.xlsx"</span>)</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.iloc[<span class="dv">0</span>:]</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>new_headers <span class="op">=</span> df_2023.iloc[<span class="dv">0</span>]</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>df_2023.columns <span class="op">=</span> new_headers</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span>df_2023[<span class="dv">1</span>:]</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>Valid_count_2023 <span class="op">=</span> df_2023[df_2023[<span class="st">'Gültigkeit'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2023<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2019 data set of which </span><span class="sc">{</span>Valid_count_2023<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>df_2023.drop(df_2023[df_2023[<span class="st">'Gültigkeit'</span>] <span class="op">==</span> <span class="st">'Ungültig (per Beschluss)'</span>].index, inplace <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>df_2023.drop(df_2023[df_2023[<span class="st">'Gültigkeit'</span>] <span class="op">==</span> <span class="st">'Ungültig'</span>].index, inplace <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.drop(columns<span class="op">=</span><span class="st">"Gültigkeit"</span>)</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.drop(columns<span class="op">=</span><span class="st">"Bemerkung"</span>)</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>df_2023.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.astype(<span class="bu">str</span>)</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2023.to_pickle("../../Data/prepared_date/Bremen_2023.pkl")</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2023</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>bremen_2023_percent <span class="op">=</span> party_percentage_dist(df_2023, party_codes, year, district)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>There are a total of 232883 voters in the 2011 Bremen data set of which 225621 successfully cast their votes</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>There are a total of 210604 voters in the 2015 data set of which 204466 successfully cast their votes</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>There are a total of 260951 voters in the 2019 data set of which 255119 successfully cast their votes</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>There are a total of 227160 voters in the 2019 data set of which 0 successfully cast their votes</code></pre>
</div>
</div>
<section id="analysis-of-party-vote-percentages-trends-over-four-elections" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="analysis-of-party-vote-percentages-trends-over-four-elections"><span class="header-section-number">3.3.1</span> Analysis of Party Vote Percentages Trends Over Four Elections</h3>
<p>This chapter uses in-depth visuals to examine Bremen’s vote trends during the last four election cycles. We can tell which political parties have seen a rise in support and which have seen a fall by looking at bar charts and line graphs that show the movements in party vote percentages. We can plainly see how the political scene is changing and how voter preferences are dynamically shifting thanks to these visual tools. This chapter seeks to give readers a thorough grasp of how various parties have fared over time, along with insights into the causes of these shifts and their consequences for upcoming elections.</p>
<div class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tabulate <span class="im">import</span> tabulate</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>top_n <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>table_2011_party <span class="op">=</span> tabulate(bremen_2011_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>df_2011_sorted <span class="op">=</span> bremen_2011_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>top_merged_df_2011 <span class="op">=</span> df_2011_sorted.head(top_n)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>table_2015_party <span class="op">=</span> tabulate(bremen_2015_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>df_2015_sorted <span class="op">=</span> bremen_2015_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>top_merged_df_2015 <span class="op">=</span> df_2015_sorted.head(top_n)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>table_2019_party <span class="op">=</span> tabulate(bremen_2019_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>df_2019_sorted <span class="op">=</span> bremen_2019_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>top_merged_df_2019 <span class="op">=</span> df_2019_sorted.head(top_n)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>table_2023_party <span class="op">=</span> tabulate(bremen_2023_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>df_2023_sorted <span class="op">=</span> bremen_2023_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>top_merged_df_2023 <span class="op">=</span>  df_2023_sorted.head(top_n)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_and_print_tables(tables, titles):</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> title, table <span class="kw">in</span> <span class="bu">zip</span>(titles, tables):</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>title<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(table)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">80</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Prepare the tables</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="co">table_2011_party = tabulate(top_merged_df_2011, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="co">table_2015_party = tabulate(top_merged_df_2015, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="co">table_2019_party = tabulate(top_merged_df_2019, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="co">table_2023_party = tabulate(top_merged_df_2023, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>titles_side_by_side <span class="op">=</span> [<span class="st">"Bremen 2011"</span>, <span class="st">"Bremen 2015"</span>]</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>titles_beneath <span class="op">=</span> [<span class="st">"Bremen 2019"</span>, <span class="st">"Bremen 2023"</span>]</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Titles for the tables</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Bremen 2011"</span>, <span class="st">"Bremen 2015"</span>, <span class="st">"Bremen 2019"</span>, <span class="st">"Bremen 2023"</span>]</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Print each table on its own line</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>format_and_print_tables([table_2011_party, table_2015_party, table_2019_party, table_2023_party], titles)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Bremen 2011

+----+------------+---------------+----------------+-----------------------+----------+
|    |   party_id |   total_count |   percentage % | Kurzform              | Colour   |
+====+============+===============+================+=======================+==========+
|  0 |        100 |        438991 |          39.35 | SPD                   | red      |
+----+------------+---------------+----------------+-----------------------+----------+
|  1 |        200 |        227622 |          20.4  | CDU                   | black    |
+----+------------+---------------+----------------+-----------------------+----------+
|  2 |        300 |        251863 |          22.57 | GRÜNE                 | green    |
+----+------------+---------------+----------------+-----------------------+----------+
|  3 |        400 |         64824 |           5.81 | DIE LINKE             | purple   |
+----+------------+---------------+----------------+-----------------------+----------+
|  4 |        500 |         25255 |           2.26 | FDP                   | yellow   |
+----+------------+---------------+----------------+-----------------------+----------+
|  5 |        600 |         34713 |           3.11 | BIW                   | orange   |
+----+------------+---------------+----------------+-----------------------+----------+
|  6 |        700 |          5439 |           0.49 | BBL                   | nan      |
+----+------------+---------------+----------------+-----------------------+----------+
|  7 |        800 |          5136 |           0.46 | Dialog Grundeinkommen | nan      |
+----+------------+---------------+----------------+-----------------------+----------+
|  8 |        900 |          9869 |           0.88 | B+B                   | nan      |
+----+------------+---------------+----------------+-----------------------+----------+
|  9 |       1000 |          3651 |           0.33 | BIP                   | nan      |
+----+------------+---------------+----------------+-----------------------+----------+
| 10 |       1100 |          2437 |           0.22 | FA                    | nan      |
+----+------------+---------------+----------------+-----------------------+----------+
| 11 |       1300 |         15944 |           1.43 | NPD                   | nan      |
+----+------------+---------------+----------------+-----------------------+----------+
| 12 |       1400 |         21074 |           1.89 | PIRATEN               | nan      |
+----+------------+---------------+----------------+-----------------------+----------+
| 13 |       1600 |          8868 |           0.79 | RRP                   | nan      |
+----+------------+---------------+----------------+-----------------------+----------+

================================================================================

Bremen 2015

+----+------------+---------------+----------------+------------------+----------+
|    |   party_id |   total_count |   percentage % | Kurzform         | Colour   |
+====+============+===============+================+==================+==========+
|  0 |        100 |        329139 |          32.64 | SPD              | red      |
+----+------------+---------------+----------------+------------------+----------+
|  1 |        200 |        158931 |          15.76 | GRÜNE            | green    |
+----+------------+---------------+----------------+------------------+----------+
|  2 |        300 |        223731 |          22.19 | CDU              | black    |
+----+------------+---------------+----------------+------------------+----------+
|  3 |        400 |        100220 |           9.94 | DIE LINKE        | purple   |
+----+------------+---------------+----------------+------------------+----------+
|  4 |        500 |         27417 |           2.72 | BIW              | orange   |
+----+------------+---------------+----------------+------------------+----------+
|  5 |        600 |         67996 |           6.74 | FDP              | yellow   |
+----+------------+---------------+----------------+------------------+----------+
|  6 |        700 |         13836 |           1.37 | PIRATEN          | nan      |
+----+------------+---------------+----------------+------------------+----------+
|  7 |        900 |         56421 |           5.6  | AfD              | blue     |
+----+------------+---------------+----------------+------------------+----------+
|  8 |       1000 |         18983 |           1.88 | Die PARTEI       | nan      |
+----+------------+---------------+----------------+------------------+----------+
|  9 |       1100 |         11682 |           1.16 | Tierschutzpartei | nan      |
+----+------------+---------------+----------------+------------------+----------+

================================================================================

Bremen 2019

+----+------------+---------------+----------------+------------------+----------+
|    |   party_id |   total_count |   percentage % | Kurzform         | Colour   |
+====+============+===============+================+==================+==========+
|  0 |        100 |        314530 |          24.93 | SPD              | red      |
+----+------------+---------------+----------------+------------------+----------+
|  1 |        200 |        343530 |          27.23 | CDU              | black    |
+----+------------+---------------+----------------+------------------+----------+
|  2 |        300 |        221509 |          17.56 | GRÜNE            | green    |
+----+------------+---------------+----------------+------------------+----------+
|  3 |        400 |        148544 |          11.77 | DIE LINKE        | purple   |
+----+------------+---------------+----------------+------------------+----------+
|  4 |        500 |         75420 |           5.98 | FDP              | yellow   |
+----+------------+---------------+----------------+------------------+----------+
|  5 |        600 |         71278 |           5.65 | AfD              | blue     |
+----+------------+---------------+----------------+------------------+----------+
|  6 |        700 |         20691 |           1.64 | BIW              | orange   |
+----+------------+---------------+----------------+------------------+----------+
|  7 |        800 |         24324 |           1.93 | Die PARTEI       | nan      |
+----+------------+---------------+----------------+------------------+----------+
|  8 |        900 |          9675 |           0.77 | PIRATEN          | nan      |
+----+------------+---------------+----------------+------------------+----------+
|  9 |       1000 |          5939 |           0.47 | BGE              | nan      |
+----+------------+---------------+----------------+------------------+----------+
| 10 |       1200 |         12714 |           1.01 | FA               | nan      |
+----+------------+---------------+----------------+------------------+----------+
| 11 |       1300 |          2559 |           0.2  | MENSCHLICHE WELT | nan      |
+----+------------+---------------+----------------+------------------+----------+
| 12 |       1400 |          6637 |           0.53 | Die Humanisten   | nan      |
+----+------------+---------------+----------------+------------------+----------+
| 13 |       1500 |          4269 |           0.34 | V-Partei         | nan      |
+----+------------+---------------+----------------+------------------+----------+

================================================================================

Bremen 2023

+----+------------+---------------+----------------+----------------------+----------+
|    |   party_id |   total_count |   percentage % | Kurzform             | Colour   |
+====+============+===============+================+======================+==========+
|  0 |        100 |        296158 |          26.95 | CDU                  | black    |
+----+------------+---------------+----------------+----------------------+----------+
|  1 |        200 |        328835 |          29.92 | SPD                  | red      |
+----+------------+---------------+----------------+----------------------+----------+
|  2 |        300 |        128442 |          11.69 | GRÜNE                | green    |
+----+------------+---------------+----------------+----------------------+----------+
|  3 |        400 |        127559 |          11.61 | DIE LINKE            | purple   |
+----+------------+---------------+----------------+----------------------+----------+
|  4 |        500 |         55532 |           5.05 | FDP                  | yellow   |
+----+------------+---------------+----------------+----------------------+----------+
|  5 |        600 |         81203 |           7.39 | BIW                  | orange   |
+----+------------+---------------+----------------+----------------------+----------+
|  6 |        700 |         12052 |           1.1  | Die PARTEI           | nan      |
+----+------------+---------------+----------------+----------------------+----------+
|  7 |        900 |          9988 |           0.91 | dieBasis             | nan      |
+----+------------+---------------+----------------+----------------------+----------+
|  8 |       1000 |          5351 |           0.49 | GFA                  | nan      |
+----+------------+---------------+----------------+----------------------+----------+
|  9 |       1100 |          1993 |           0.18 | MLPD                 | nan      |
+----+------------+---------------+----------------+----------------------+----------+
| 10 |       1200 |          7912 |           0.72 | MERA25               | nan      |
+----+------------+---------------+----------------+----------------------+----------+
| 11 |       1300 |          3756 |           0.34 | ÖDP                  | nan      |
+----+------------+---------------+----------------+----------------------+----------+
| 12 |       1400 |          1484 |           0.14 | Verjüngungsforschung | nan      |
+----+------------+---------------+----------------+----------------------+----------+
| 13 |       1500 |         13819 |           1.26 | Tierschutzpartei     | nan      |
+----+------------+---------------+----------------+----------------------+----------+
| 14 |       1600 |         24848 |           2.26 | Volt                 | nan      |
+----+------------+---------------+----------------+----------------------+----------+

================================================================================
</code></pre>
</div>
</div>
<p>The bar charts plotted below illustrate the percentage of votes received by each political party in Bremen over the last four electoral cycles. These visualizations provide a clear depiction of the shifting political landscape in the region. The Social Democratic Party (SPD) has traditionally maintained a strong presence, although its vote share has fluctuated. The Christian Democratic Union (CDU) has similarly experienced variations in its support base, reflecting changing voter sentiments. The Green Party (Die Grünen) has shown a steady increase in vote percentages, highlighting growing environmental and social awareness among the electorate. Conversely, the Left Party (Die Linke) and the Free Democratic Party (FDP) have witnessed more variable performance, indicative of their targeted, sometimes niche appeal. Notably, the rise of the Alternative for Germany (AfD), a far-right party, underscores a significant shift in a portion of the voter base towards more nationalist and populist ideologies. These bar charts not only showcase the ebb and flow of party support but also offer insights into broader electoral trends and the evolving political priorities of Bremen’s voters. This analysis forms a crucial foundation for understanding the dynamics of voter behavior and the strategic adaptations of political parties over time.</p>
<div class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">16</span>))</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_color(row):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">'grey'</span> <span class="cf">if</span> pd.isna(row[<span class="st">'Colour'</span>]) <span class="cf">else</span> row[<span class="st">'Colour'</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df, ax, title <span class="kw">in</span> <span class="bu">zip</span>([top_merged_df_2011, top_merged_df_2015, top_merged_df_2019, top_merged_df_2023],</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                         axs.flatten(), [<span class="st">'Bremen 2011'</span>, <span class="st">'Bremen 2015'</span>, <span class="st">'Bremen 2019'</span>, <span class="st">'Bremen 2023'</span>]):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    df.plot.bar(x<span class="op">=</span><span class="st">'Kurzform'</span>, y<span class="op">=</span><span class="st">'percentage %'</span>, rot<span class="op">=</span><span class="dv">0</span>, ax<span class="op">=</span>ax, color<span class="op">=</span>df.<span class="bu">apply</span>(get_color, axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-4-output-1.png" width="753" height="1526"></p>
</div>
</div>
<p>The line graph presented below highlights the changing vote percentages for each political party in Bremen over the past four electoral cycles, offering a dynamic view of party growth and decline. The graph traces the trajectory of each party’s performance, revealing significant trends and shifts in voter allegiance.</p>
<p>The Social Democratic Party (SPD) has shown a general decline over the years. In 2011, the SPD garnered almost 40% of the votes, but this support has steadily decreased, reaching a low of about 25% in 2015. This downward trend indicates a diminishing traditional support base for the SPD in Bremen.</p>
<p>Conversely, the Christian Democratic Union (CDU) is on an upward trajectory. Starting with approximately 20% of the votes in 2011, the CDU has seen a steady increase over the years, reaching around 27% in the most recent election. This growth suggests a strengthening of the CDU’s appeal among Bremen’s electorate.</p>
<p>The Green Party (Die Grünen) has experienced a steady decrease in its vote share, declining from about 23% in 2011 to 17% in 2023. This trend reflects a shift in voter priorities or a possible realignment of the environmental and progressive agenda within the broader political spectrum.</p>
<p>The Left Party (Die Linke) is on a steady increase, with its vote share rising from 6% in 2011 to about 12% in 2023. This upward trend indicates a growing appeal for the Left Party’s platform and policies among voters in Bremen.</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> bremen_2011_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2011'</span>})</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> bremen_2015_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2015'</span>})</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> bremen_2019_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2019'</span>})</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> bremen_2023_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2023'</span>})</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> df_2011.merge(df_2015, on<span class="op">=</span>[<span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>], how<span class="op">=</span><span class="st">'outer'</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.merge(df_2019, on<span class="op">=</span>[<span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>], how<span class="op">=</span><span class="st">'outer'</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.merge(df_2023, on<span class="op">=</span>[<span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>], how<span class="op">=</span><span class="st">'outer'</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.fillna({<span class="st">'2011'</span>: <span class="dv">0</span>, <span class="st">'2015'</span>: <span class="dv">0</span>, <span class="st">'2019'</span>: <span class="dv">0</span>, <span class="st">'2023'</span>: <span class="dv">0</span>})</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>merged_df[<span class="st">'Colour'</span>] <span class="op">=</span> merged_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>others_df <span class="op">=</span> merged_df[merged_df[<span class="st">'Colour'</span>] <span class="op">==</span> <span class="st">'grey'</span>]</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>others_sums <span class="op">=</span> others_df[[<span class="st">'2011'</span>, <span class="st">'2015'</span>, <span class="st">'2019'</span>, <span class="st">'2023'</span>]].<span class="bu">sum</span>()</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>others_sums[<span class="st">'Kurzform'</span>] <span class="op">=</span> <span class="st">'Others'</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>others_sums[<span class="st">'Colour'</span>] <span class="op">=</span> <span class="st">'grey'</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>filtered_df <span class="op">=</span> merged_df[merged_df[<span class="st">'Colour'</span>] <span class="op">!=</span> <span class="st">'grey'</span>]</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> pd.concat([filtered_df, pd.DataFrame([others_sums])], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>final_df.set_index(<span class="st">'Kurzform'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>transposed_df <span class="op">=</span> final_df[[<span class="st">'2011'</span>, <span class="st">'2015'</span>, <span class="st">'2019'</span>, <span class="st">'2023'</span>]].T</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> party <span class="kw">in</span> transposed_df.columns:</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    plt.plot(transposed_df.index, transposed_df[party], marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span>party, color<span class="op">=</span>final_df.loc[party, <span class="st">'Colour'</span>])</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Votes of Each Party in Bremen Elections (2011-2023)'</span>)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Year'</span>)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Vote Percentage'</span>)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">'Party'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">1.05</span>, <span class="dv">1</span>), loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>plt.show()  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-5-output-1.png" width="756" height="566"></p>
</div>
</div>
<p>Additionally, the political landscape has been enriched by the emergence of new parties such as Volt. Although still gaining traction, Volt’s presence in the political arena signifies the evolving nature of voter preferences and the increasing diversification of political representation.</p>
<p>Overall, the line graph effectively captures the dynamic and evolving nature of political party support in Bremen. It provides valuable insights into how parties have adapted to changing voter priorities and the broader socio-political environment. This analysis is crucial for understanding the strategic responses of political parties and predicting future electoral outcomes.</p>
<div class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># read the party codes</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#-----------------------</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>party_codes <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Parteien-Codes.xlsx"</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>party_codes_2011 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2011</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>party_codes_2015 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2015</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>,  <span class="st">'Colour'</span>]]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>party_codes_2019 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2019</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>,  <span class="st">'Colour'</span>]]</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>party_codes_2023 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2023</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>,  <span class="st">'Colour'</span>]]</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Load datasets and get the numbers of voters for each party</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co">#------</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2011.pkl"</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2015.pkl"</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2019.pkl"</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2023.pkl"</span>)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_hundredth(df):</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="bu">int</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="kw">lambda</span> x: (x <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>df_bre_2011 <span class="op">=</span> convert_to_hundredth(df_2011)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>df_bre_2015 <span class="op">=</span> convert_to_hundredth(df_2015)</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>df_bre_2019 <span class="op">=</span> convert_to_hundredth(df_2019)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>df_bre_2023 <span class="op">=</span> convert_to_hundredth(df_2023)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="co">############ -----------------------------</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="co">#Convert the party codes to names</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> replace_codes_with_names(df_data, df_codes):</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>    merged_columns <span class="op">=</span> []</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> code_column <span class="kw">in</span> [<span class="st">'Stimme 1'</span>, <span class="st">'Stimme 2'</span>, <span class="st">'Stimme 3'</span>, <span class="st">'Stimme 4'</span>, <span class="st">'Stimme 5'</span>]:</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        merged_df <span class="op">=</span> pd.merge(df_data, df_codes, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span>code_column, right_on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>        merged_df.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> merged_df.columns <span class="cf">if</span> col <span class="op">!=</span> <span class="st">'Kurzform'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>        merged_df.rename(columns<span class="op">=</span>{<span class="st">'Kurzform'</span>: code_column}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>        merged_columns.append(merged_df)</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>    final_df <span class="op">=</span> pd.concat(merged_columns, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_df</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>df_bre_2011_prty <span class="op">=</span> replace_codes_with_names(df_bre_2011, party_codes_2011)</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>df_bre_2015_prty <span class="op">=</span> replace_codes_with_names(df_bre_2015, party_codes_2015)</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>df_bre_2019_prty <span class="op">=</span> replace_codes_with_names(df_bre_2019, party_codes_2019)</span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>df_bre_2023_prty <span class="op">=</span> replace_codes_with_names(df_bre_2023, party_codes_2023)</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------------</span></span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to get total voters for each pary</span></span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------</span></span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_total_voters(df):</span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.dropna()</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>    unique_counts <span class="op">=</span> {}</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a>        unique_values_in_row <span class="op">=</span> <span class="bu">set</span>(row)</span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> value <span class="kw">in</span> unique_values_in_row:</span>
<span id="cb10-70"><a href="#cb10-70" aria-hidden="true" tabindex="-1"></a>            unique_counts[value] <span class="op">=</span> unique_counts.get(value, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-71"><a href="#cb10-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-72"><a href="#cb10-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the dictionary to a DataFrame</span></span>
<span id="cb10-73"><a href="#cb10-73" aria-hidden="true" tabindex="-1"></a>    unique_counts_df <span class="op">=</span> pd.DataFrame(<span class="bu">list</span>(unique_counts.items()), columns<span class="op">=</span>[<span class="st">'Party_id'</span>, <span class="st">'Total_voters'</span>])</span>
<span id="cb10-74"><a href="#cb10-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">#df_party = df_party_pairs.merge(df_total_voters, how='left', left_on='Party_Code_A', right_on='Party_id')</span></span>
<span id="cb10-75"><a href="#cb10-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-76"><a href="#cb10-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> unique_counts_df</span>
<span id="cb10-77"><a href="#cb10-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-78"><a href="#cb10-78" aria-hidden="true" tabindex="-1"></a>df_2011_total_voters <span class="op">=</span> count_total_voters(df_bre_2011_prty)</span>
<span id="cb10-79"><a href="#cb10-79" aria-hidden="true" tabindex="-1"></a>df_2015_total_voters <span class="op">=</span> count_total_voters(df_bre_2015_prty)</span>
<span id="cb10-80"><a href="#cb10-80" aria-hidden="true" tabindex="-1"></a>df_2019_total_voters <span class="op">=</span> count_total_voters(df_bre_2019_prty)</span>
<span id="cb10-81"><a href="#cb10-81" aria-hidden="true" tabindex="-1"></a>df_2023_total_voters <span class="op">=</span> count_total_voters(df_bre_2023_prty)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Co-voter Percentage Matrix</strong> In the first approach, we constructed a matrix based on the percentages of co-voters for each pair of political parties. Here, co-voters are defined as voters who voted for both parties in question. For each pair of parties, we calculated the average of co-voters on both direction, ie avegrage of percentage of Party A voters that voted for Party B and vice viser. This method emphasizes the overlap in voter bases between different parties, providing insight into potential alliances or ideological similarities.</p>
<p>For example, if Party A and Party B share a significant percentage of their voters, this will result in a higher value in the co-voter percentage matrix. Likewise, parties with minimal overlap in their voter bases will show lower values. This matrix, therefore, serves as a measure of voter commonality and helps identify clusters of parties with shared electorates and share common values.</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------------</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate Uniqure pairs of parties that voters voted for</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># ---------------------------</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unique_pairs_with_count(df):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="bu">int</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    pair_counter <span class="op">=</span> Counter()</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        row_values <span class="op">=</span> [(x <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span> <span class="dv">100</span> <span class="cf">for</span> x <span class="kw">in</span> row <span class="cf">if</span> x<span class="op">!=</span> <span class="dv">0</span>]</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        unique_pairs <span class="op">=</span> <span class="bu">set</span>(combinations(row_values, <span class="dv">2</span>))</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        pair_counter.update(unique_pairs)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    pair_counts_df <span class="op">=</span> pd.DataFrame(pair_counter.items(), columns<span class="op">=</span>[<span class="st">'Pair'</span>, <span class="st">'Count'</span>])</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    pair_counts_df[[<span class="st">'Party_Code_A'</span>, <span class="st">'Party_Code_B'</span>]] <span class="op">=</span> pd.DataFrame(pair_counts_df[<span class="st">'Pair'</span>].tolist())</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    pair_counts_df <span class="op">=</span> pair_counts_df[[<span class="st">'Party_Code_A'</span>, <span class="st">'Party_Code_B'</span>, <span class="st">'Count'</span>]]</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pair_counts_df</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>df_2011_pair <span class="op">=</span> unique_pairs_with_count(df_2011)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>df_2015_pair <span class="op">=</span> unique_pairs_with_count(df_2015)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>df_2019_pair <span class="op">=</span> unique_pairs_with_count(df_2019)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>df_2023_pair <span class="op">=</span> unique_pairs_with_count(df_2023)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>df_2011_pair.head(<span class="dv">10</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="co">#------------------------</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Replace party codes with party names in the covoter dataframe </span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="co">#-------------------------</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_and_clean(df, party_codes):</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">#df_merged= df.merge(party_votes, how='left', left_on ='Party_Code_A', right_on= ['Party_id'])</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Merge with party codes for party A</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>    df_merged <span class="op">=</span> df.merge(party_codes, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'Party_Code_A'</span>, right_on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    df_merged.drop(columns<span class="op">=</span>[<span class="st">'party_id'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    df_merged.rename(columns<span class="op">=</span>{<span class="st">'Kurzform'</span>: <span class="st">'party_A'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Merge with party codes for party B</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    df_merged <span class="op">=</span> df_merged.merge(party_codes, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'Party_Code_B'</span>, right_on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>    df_merged.drop(columns<span class="op">=</span>[<span class="st">'party_id'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    df_merged.rename(columns<span class="op">=</span>{<span class="st">'Kurzform'</span>: <span class="st">'party_B'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_merged</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>df_2011_party_pairs <span class="op">=</span> merge_and_clean(df_2011_pair, party_codes_2011)</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>df_2015_party_pairs <span class="op">=</span> merge_and_clean(df_2015_pair, party_codes_2015)</span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>df_2019_party_pairs <span class="op">=</span> merge_and_clean(df_2019_pair, party_codes_2019)</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>df_2023_party_pairs <span class="op">=</span> merge_and_clean(df_2023_pair, party_codes_2023)</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>df_2011_party_pairs.head(<span class="dv">10</span>)</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------------------</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the avaerage percentage of co voters to compute the matrix</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------------------</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_party_voting_percentages(df_party_pairs, df_total_voters):</span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>    df_party <span class="op">=</span> df_party_pairs.merge(df_total_voters, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'party_A'</span>, right_on<span class="op">=</span><span class="st">'Party_id'</span>)</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>    df_party[<span class="st">'Percentage_A_voted_B'</span>] <span class="op">=</span> (df_party[<span class="st">'Count'</span>] <span class="op">/</span> df_party[<span class="st">'Total_voters'</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>    df_party.drop(columns<span class="op">=</span>[<span class="st">'Total_voters'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>    df_party <span class="op">=</span> df_party.merge(df_total_voters, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'party_B'</span>, right_on<span class="op">=</span><span class="st">'Party_id'</span>, suffixes<span class="op">=</span>(<span class="st">'_A'</span>, <span class="st">'_B'</span>))</span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>    df_party[<span class="st">'Percentage_B_voted_A'</span>] <span class="op">=</span> (df_party[<span class="st">'Count'</span>] <span class="op">/</span> df_party[<span class="st">'Total_voters'</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>    df_party.drop(columns<span class="op">=</span>[<span class="st">'Total_voters'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>    df_party_result <span class="op">=</span> df_party[[<span class="st">'party_A'</span>, <span class="st">'party_B'</span>, <span class="st">'Count'</span>, <span class="st">'Percentage_A_voted_B'</span>, <span class="st">'Percentage_B_voted_A'</span>]]</span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>    df_party_result[<span class="st">'Average_percentage'</span>] <span class="op">=</span> ((df_party_result[<span class="st">'Percentage_A_voted_B'</span>] <span class="op">+</span> df_party_result[<span class="st">'Percentage_B_voted_A'</span>]) <span class="op">/</span> <span class="dv">200</span>).<span class="bu">round</span>(<span class="dv">1</span>)</span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_party_result</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>df_2011_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2011_party_pairs,df_2011_total_voters)</span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>df_2015_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2015_party_pairs,df_2015_total_voters)</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>df_2019_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2019_party_pairs,df_2019_total_voters)</span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>df_2023_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2023_party_pairs,df_2023_total_voters)</span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>df_2011_party_percentages.head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\manja\AppData\Local\Temp\ipykernel_22228\3414713232.py:74: SettingWithCopyWarning:


A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

C:\Users\manja\AppData\Local\Temp\ipykernel_22228\3414713232.py:74: SettingWithCopyWarning:


A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

C:\Users\manja\AppData\Local\Temp\ipykernel_22228\3414713232.py:74: SettingWithCopyWarning:


A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

C:\Users\manja\AppData\Local\Temp\ipykernel_22228\3414713232.py:74: SettingWithCopyWarning:


A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="6">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>party_A</th>
      <th>party_B</th>
      <th>Count</th>
      <th>Percentage_A_voted_B</th>
      <th>Percentage_B_voted_A</th>
      <th>Average_percentage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>SPD</td>
      <td>SPD</td>
      <td>105910</td>
      <td>94.716414</td>
      <td>94.716414</td>
      <td>0.9</td>
    </tr>
    <tr>
      <th>1</th>
      <td>SPD</td>
      <td>CDU</td>
      <td>9739</td>
      <td>8.709689</td>
      <td>18.067975</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>SPD</td>
      <td>GRÜNE</td>
      <td>39435</td>
      <td>35.267131</td>
      <td>51.847908</td>
      <td>0.4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>SPD</td>
      <td>DIE LINKE</td>
      <td>5917</td>
      <td>5.291635</td>
      <td>30.401274</td>
      <td>0.2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>SPD</td>
      <td>FDP</td>
      <td>2058</td>
      <td>1.840491</td>
      <td>24.691062</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>5</th>
      <td>SPD</td>
      <td>BIW</td>
      <td>2534</td>
      <td>2.266183</td>
      <td>24.625850</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>6</th>
      <td>SPD</td>
      <td>BBL</td>
      <td>640</td>
      <td>0.572359</td>
      <td>32.128514</td>
      <td>0.2</td>
    </tr>
    <tr>
      <th>7</th>
      <td>SPD</td>
      <td>Dialog Grundeinkommen</td>
      <td>509</td>
      <td>0.455204</td>
      <td>23.663412</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>8</th>
      <td>SPD</td>
      <td>B+B</td>
      <td>920</td>
      <td>0.822766</td>
      <td>28.316405</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>9</th>
      <td>SPD</td>
      <td>BIP</td>
      <td>601</td>
      <td>0.537481</td>
      <td>43.709091</td>
      <td>0.2</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_percentage_matrix(df):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get unique values of party_A and party_B</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    unique_party_A <span class="op">=</span> df[<span class="st">'party_A'</span>].unique()</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    unique_party_B <span class="op">=</span> df[<span class="st">'party_B'</span>].unique()</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>unique_party_A, columns<span class="op">=</span>unique_party_A)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> party_A <span class="kw">in</span> unique_party_A:</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> party_B <span class="kw">in</span> unique_party_A:</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>            subset_df <span class="op">=</span> df[(df[<span class="st">'party_A'</span>] <span class="op">==</span> party_A) <span class="op">&amp;</span> (df[<span class="st">'party_B'</span>] <span class="op">==</span> party_B)]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> subset_df.empty:</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                average_percentage <span class="op">=</span> subset_df[<span class="st">'Average_percentage'</span>].values[<span class="dv">0</span>] </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>                matrix.loc[party_A, party_B] <span class="op">=</span> average_percentage</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    matrix.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mirror the lower triangle to the upper triangle</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(matrix)):</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>            matrix.iloc[i, j] <span class="op">=</span> matrix.iloc[j, i]</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"This gives a Upper truangular matrix or Right trainagular, so I mirrowed the lower traingular matrix to the upper triangular to get a full symmetrix matrix"</span>)</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Call the function with your DataFrame</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>matrix_bre_2011 <span class="op">=</span> create_percentage_matrix(df_2011_party_percentages)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>matrix_bre_2015 <span class="op">=</span> create_percentage_matrix(df_2015_party_percentages)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>matrix_bre_2019 <span class="op">=</span> create_percentage_matrix(df_2019_party_percentages)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>matrix_bre_2023 <span class="op">=</span> create_percentage_matrix(df_2023_party_percentages)</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tabulate(matrix_bre_2011, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>This gives a Upper truangular matrix or Right trainagular, so I mirrowed the lower traingular matrix to the upper triangular to get a full symmetrix matrix</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
|                       |   SPD |   CDU |   GRÜNE |   DIE LINKE |   FDP |   BIW |   BBL |   Dialog Grundeinkommen |   B+B |   BIP |   FA |   NPD |   PIRATEN |   RRP |
+=======================+=======+=======+=========+=============+=======+=======+=======+=========================+=======+=======+======+=======+===========+=======+
| SPD                   |   0.9 |   0.1 |     0.4 |         0.2 |   0.1 |   0.1 |   0.2 |                     0.1 |   0.1 |   0.2 |  0.2 |   0.1 |       0.2 |   0.2 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| CDU                   |   0.1 |   0.9 |     0.1 |         0   |   0.2 |   0.1 |   0.1 |                     0   |   0.1 |   0.1 |  0.1 |   0.1 |       0   |   0.1 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| GRÜNE                 |   0.4 |   0.1 |     0.9 |         0.2 |   0.1 |   0.1 |   0.1 |                     0.3 |   0.1 |   0.2 |  0.1 |   0   |       0.2 |   0.1 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| DIE LINKE             |   0.2 |   0   |     0.2 |         0.8 |   0   |   0.1 |   0   |                     0.2 |   0   |   0.1 |  0   |   0   |       0.1 |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| FDP                   |   0.1 |   0.2 |     0.1 |         0   |   0.7 |   0   |   0   |                     0   |   0   |   0   |  0   |   0   |       0   |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| BIW                   |   0.1 |   0.1 |     0.1 |         0.1 |   0   |   0.8 |   0.1 |                     0   |   0.1 |   0   |  0.1 |   0.1 |       0.1 |   0.1 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| BBL                   |   0.2 |   0.1 |     0.1 |         0   |   0   |   0.1 |   0.6 |                     0   |   0.1 |   0   |  0.1 |   0   |       0.1 |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| Dialog Grundeinkommen |   0.1 |   0   |     0.3 |         0.2 |   0   |   0   |   0   |                     0.6 |   0   |   0   |  0   |   0   |       0.1 |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| B+B                   |   0.1 |   0.1 |     0.1 |         0   |   0   |   0.1 |   0.1 |                     0   |   0.7 |   0   |  0.1 |   0   |       0   |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| BIP                   |   0.2 |   0.1 |     0.2 |         0.1 |   0   |   0   |   0   |                     0   |   0   |   0.6 |  0   |   0   |       0.1 |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| FA                    |   0.2 |   0.1 |     0.1 |         0   |   0   |   0.1 |   0.1 |                     0   |   0.1 |   0   |  0.6 |   0   |       0.1 |   0.1 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| NPD                   |   0.1 |   0.1 |     0   |         0   |   0   |   0.1 |   0   |                     0   |   0   |   0   |  0   |   0.9 |       0   |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| PIRATEN               |   0.2 |   0   |     0.2 |         0.1 |   0   |   0.1 |   0.1 |                     0.1 |   0   |   0.1 |  0.1 |   0   |       0.7 |   0   |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| RRP                   |   0.2 |   0.1 |     0.1 |         0   |   0   |   0.1 |   0   |                     0   |   0   |   0   |  0.1 |   0   |       0   |   0.7 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+</code></pre>
</div>
</div>
<p><strong>Union-to-Intersection Ratio Matrix</strong> The second approach involved calculating the ratio of the union to the intersection of co-voters for each pair of political parties. This ratio captures the relative breadth and exclusivity of party support. Specifically, the union represents the total number of unique voters for either party, while the intersection denotes the number of voters who supported both parties.</p>
<p>Mathematically, this ratio is defined as: <span class="math display">\[
Union-to-Intersection Ratio = \frac{∣Union  of  co-voters∣}{∣Intersection  of  co-voters∣}
\]</span></p>
<p>A higher ratio indicates that while there is some overlap in voter bases, each party also attracts a significant number of unique voters. This can highlight distinct but occasionally intersecting political constituencies. In contrast, a lower ratio suggests a stronger mutual reliance on the same voter base, indicating a closer relationship or similarity between the parties.</p>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------------------------</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co"># get function to create a matrix for the ration of the common voters to all voter</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------- </span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_votes_for_pairs(df):</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="bu">int</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    pair_counter <span class="op">=</span> Counter()</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'party_a_intersection_party_b'</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'party_a_union_party_b'</span>] <span class="op">=</span> <span class="dv">0</span> </span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        row_values <span class="op">=</span> [(x <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span> <span class="dv">100</span> <span class="cf">for</span> x <span class="kw">in</span> row <span class="cf">if</span> x<span class="op">!=</span> <span class="dv">0</span>]   </span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        unique_pairs <span class="op">=</span> <span class="bu">set</span>(combinations(row_values, <span class="dv">2</span>)) </span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        pair_counter.update(unique_pairs)   </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    pair_counts_df <span class="op">=</span> pd.DataFrame(pair_counter.items(), columns<span class="op">=</span>[<span class="st">'Pair'</span>, <span class="st">'Count'</span>])  </span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    pair_counts_df[[<span class="st">'Party_Code_A'</span>, <span class="st">'Party_Code_B'</span>]] <span class="op">=</span> pd.DataFrame(pair_counts_df[<span class="st">'Pair'</span>].tolist())</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">#pair_counts_df = pair_counts_df[['Party_Code_A', 'Party_Code_B', 'Count']]</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over each row in the DataFrame</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        party_a <span class="op">=</span> row[<span class="st">'Party_Code_A'</span>]</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        party_b <span class="op">=</span> row[<span class="st">'Party_Code_B'</span>]</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Count votes for both parties and votes for either party</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        votes_for_both <span class="op">=</span> df[(df[<span class="st">'Party_Code_A'</span>] <span class="op">==</span> party_a) <span class="op">&amp;</span> (df[<span class="st">'Party_Code_B'</span>] <span class="op">==</span> party_b)][<span class="st">'Count'</span>].<span class="bu">sum</span>()</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        votes_for_either <span class="op">=</span> df[(df[<span class="st">'Party_Code_A'</span>] <span class="op">==</span> party_a) <span class="op">|</span> (df[<span class="st">'Party_Code_B'</span>] <span class="op">==</span> party_b)][<span class="st">'Count'</span>].<span class="bu">sum</span>()</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        ratio_f <span class="op">=</span> (votes_for_both <span class="op">/</span> votes_for_either).<span class="bu">round</span>(<span class="dv">2</span>)</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the new columns with counts</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>        df.loc[index, <span class="st">'party_a_intersection_party_b'</span>] <span class="op">=</span> votes_for_both</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>        df.loc[index, <span class="st">'party_a_union_party_b'</span>] <span class="op">=</span> votes_for_either</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>        df.loc[index, <span class="st">'party_votes_ratio'</span>] <span class="op">=</span> ratio_f</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>df_2011_pair_union <span class="op">=</span> count_votes_for_pairs(df_2011_pair)</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>df_2015_pair_union <span class="op">=</span> count_votes_for_pairs(df_2015_pair)</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>df_2019_pair_union <span class="op">=</span> count_votes_for_pairs(df_2019_pair)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>df_2023_pair_union <span class="op">=</span> count_votes_for_pairs(df_2023_pair)</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>df_2011_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2011_pair_union, party_codes_2011)</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>df_2015_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2015_pair_union, party_codes_2015)</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>df_2019_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2019_pair_union, party_codes_2019)</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>df_2023_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2023_pair_union, party_codes_2023)</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_ratio_matrix(df):</span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get unique values of party_A and party_B</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    unique_party_A <span class="op">=</span> df[<span class="st">'party_A'</span>].unique()</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>    unique_party_B <span class="op">=</span> df[<span class="st">'party_B'</span>].unique()</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>unique_party_A, columns<span class="op">=</span>unique_party_B)</span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over each unique pair of parties and fill in the matrix with the average percentage</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> party_A <span class="kw">in</span> unique_party_A:</span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> party_B <span class="kw">in</span> unique_party_B:</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>            subset_df <span class="op">=</span> df[(df[<span class="st">'party_A'</span>] <span class="op">==</span> party_A) <span class="op">&amp;</span> (df[<span class="st">'party_B'</span>] <span class="op">==</span> party_B)]</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> subset_df.empty:</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>                voter_ratio <span class="op">=</span> subset_df[<span class="st">'party_votes_ratio'</span>].values[<span class="dv">0</span>]   </span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>                matrix.loc[party_A, party_B] <span class="op">=</span> voter_ratio</span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>    matrix.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mirror the lower triangle to the upper triangle</span></span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(matrix)):</span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>            matrix.iloc[i, j] <span class="op">=</span> matrix.iloc[j, i]</span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>matrix_bre_2011_ratio <span class="op">=</span> create_ratio_matrix(df_2011_party_pairs_ratio)</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a>matrix_bre_2015_ratio <span class="op">=</span> create_ratio_matrix(df_2015_party_pairs_ratio)</span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a>matrix_bre_2019_ratio <span class="op">=</span> create_ratio_matrix(df_2019_party_pairs_ratio)</span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a>matrix_bre_2023_ratio <span class="op">=</span> create_ratio_matrix(df_2023_party_pairs_ratio) </span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tabulate(matrix_bre_2011_ratio, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
|                       |   SPD |   CDU |   GRÜNE |   DIE LINKE |   FDP |   BIW |   BBL |   Dialog Grundeinkommen |   B+B |   BIP |   FA |   NPD |   PIRATEN |   RRP |
+=======================+=======+=======+=========+=============+=======+=======+=======+=========================+=======+=======+======+=======+===========+=======+
| SPD                   |  0.61 |  0.04 |    0.16 |        0.03 |  0.01 |  0.01 |  0    |                    0    |  0.01 |  0    | 0    |  0    |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| CDU                   |  0.04 |  0.67 |    0.04 |        0.01 |  0.05 |  0.02 |  0.01 |                    0    |  0.01 |  0    | 0    |  0.01 |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| GRÜNE                 |  0.16 |  0.04 |    0.52 |        0.07 |  0.02 |  0.02 |  0.01 |                    0.01 |  0.01 |  0.01 | 0    |  0    |      0.03 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| DIE LINKE             |  0.03 |  0.01 |    0.07 |        0.46 |  0.01 |  0.02 |  0.01 |                    0.03 |  0.01 |  0.01 | 0    |  0.01 |      0.04 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| FDP                   |  0.01 |  0.05 |    0.02 |        0.01 |  0.41 |  0.02 |  0.01 |                    0    |  0.02 |  0    | 0.01 |  0.01 |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| BIW                   |  0.01 |  0.02 |    0.02 |        0.02 |  0.02 |  0.45 |  0.03 |                    0.01 |  0.02 |  0    | 0.02 |  0.04 |      0.02 |  0.03 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| BBL                   |  0    |  0.01 |    0.01 |        0.01 |  0.01 |  0.03 |  0.3  |                    0.01 |  0.03 |  0.01 | 0.02 |  0.01 |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| Dialog Grundeinkommen |  0    |  0    |    0.01 |        0.03 |  0    |  0.01 |  0.01 |                    0.28 |  0.01 |  0.02 | 0.01 |  0    |      0.02 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| B+B                   |  0.01 |  0.01 |    0.01 |        0.01 |  0.02 |  0.02 |  0.03 |                    0.01 |  0.38 |  0.01 | 0.02 |  0.01 |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| BIP                   |  0    |  0    |    0.01 |        0.01 |  0    |  0    |  0.01 |                    0.02 |  0.01 |  0.29 | 0.01 |  0    |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| FA                    |  0    |  0    |    0    |        0    |  0.01 |  0.02 |  0.02 |                    0.01 |  0.02 |  0.01 | 0.26 |  0.01 |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| NPD                   |  0    |  0.01 |    0    |        0.01 |  0.01 |  0.04 |  0.01 |                    0    |  0.01 |  0    | 0.01 |  0.57 |      0.01 |  0.01 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| PIRATEN               |  0.01 |  0.01 |    0.03 |        0.04 |  0.01 |  0.02 |  0.01 |                    0.02 |  0.01 |  0.01 | 0.01 |  0.01 |      0.35 |  0.02 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+
| RRP                   |  0.01 |  0.01 |    0.01 |        0.01 |  0.01 |  0.03 |  0.01 |                    0.01 |  0.01 |  0.01 | 0.01 |  0.01 |      0.02 |  0.36 |
+-----------------------+-------+-------+---------+-------------+-------+-------+-------+-------------------------+-------+-------+------+-------+-----------+-------+</code></pre>
</div>
</div>
</section>
</section>
<section id="techniques" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="techniques"><span class="header-section-number">3.4</span> Techniques</h2>
</section>
<section id="dimensionality-reduction" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="dimensionality-reduction"><span class="header-section-number">3.5</span> Dimensionality Reduction</h2>
<p><strong>Dimension reduction</strong> refers to a set of techniques which can transform high-dimensional data into their representative low-dimensional data. During the process, some information of the original data is discarded but some main characteristics of the original data is preserved.</p>
<p>Three dimension reduction techniques:</p>
<ol type="1">
<li><p><strong>Principal Component Analysis (PCA)</strong> - PCA tries to project the original high-dimensional data into lower dimensions by capturing the most prominent variance in the data. It is a linear combination that projects the data lower component with respect to relative variance</p></li>
<li><p><strong>Multidimensional Scaling (MDS)</strong> - MDS is a technique for reducing data dimensions while attempting to preserve the relative distance between high-dimensional data points. It keeps the relative distances proportional</p></li>
<li><p><strong>Stochastic Neighbor Embedding (SNE)</strong> - SNE is a non-linear technique to “cluster” data points by trying to keep similar data points close to each other.</p></li>
</ol>
<section id="principal-component-analysis" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="principal-component-analysis"><span class="header-section-number">3.5.1</span> Principal Component Analysis</h3>
<p><em>Principal component analysis (PCA)</em> is often used to find a low dimensional representation of data that maximizes the spread of the projected data. The first principal component is the direction of the largest variance of the data. The second principal component is perpendicular to the first principal component and is the direction of the largest variance of the data among all directions that are perpendicular to the first principal component. The third principal component () is perpendicular to both first and second principal components and is in the direction of the largest variance among all directions that are perpendicular to both the first and second principal components <img src="../img/PCA.png" class="img-fluid" data-fig-align="center"></p>
<section id="steps-to-calculate-pca" class="level4" data-number="3.5.1.1">
<h4 data-number="3.5.1.1" class="anchored" data-anchor-id="steps-to-calculate-pca"><span class="header-section-number">3.5.1.1</span> Steps to calculate PCA</h4>
<ol type="1">
<li><strong>STANDARDIZATION</strong> This is a standard proceduer in data preparation for any machine learning algorithm, standardizing data simple mean putting the dataset in a standard range, there by removing or reducing the effects of outliers. <span class="math display">\[
standard value, z = \frac{∣value - mean∣}{Standard deviation}
\]</span> In the Matrix dataset that we’ve created in the previous chapter, the data is already standadized; the first matrix is was measured in percentages which was reduced to 0-1 in the matrix and the second matrix was also a ration of intersection to union which is also in the range of 0 and 1. So for this dataset(matrix) we will convert our marix dataset to a numpy array to ab able to perform the next steps</li>
</ol>
<div class="cell" data-execution_count="9">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>matrix_array <span class="op">=</span> matrix_bre_2011.to_numpy()</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>matrix_array</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>array([[0.9, 0.1, 0.4, 0.2, 0.1, 0.1, 0.2, 0.1, 0.1, 0.2, 0.2, 0.1, 0.2,
        0.2],
       [0.1, 0.9, 0.1, 0. , 0.2, 0.1, 0.1, 0. , 0.1, 0.1, 0.1, 0.1, 0. ,
        0.1],
       [0.4, 0.1, 0.9, 0.2, 0.1, 0.1, 0.1, 0.3, 0.1, 0.2, 0.1, 0. , 0.2,
        0.1],
       [0.2, 0. , 0.2, 0.8, 0. , 0.1, 0. , 0.2, 0. , 0.1, 0. , 0. , 0.1,
        0. ],
       [0.1, 0.2, 0.1, 0. , 0.7, 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ,
        0. ],
       [0.1, 0.1, 0.1, 0.1, 0. , 0.8, 0.1, 0. , 0.1, 0. , 0.1, 0.1, 0.1,
        0.1],
       [0.2, 0.1, 0.1, 0. , 0. , 0.1, 0.6, 0. , 0.1, 0. , 0.1, 0. , 0.1,
        0. ],
       [0.1, 0. , 0.3, 0.2, 0. , 0. , 0. , 0.6, 0. , 0. , 0. , 0. , 0.1,
        0. ],
       [0.1, 0.1, 0.1, 0. , 0. , 0.1, 0.1, 0. , 0.7, 0. , 0.1, 0. , 0. ,
        0. ],
       [0.2, 0.1, 0.2, 0.1, 0. , 0. , 0. , 0. , 0. , 0.6, 0. , 0. , 0.1,
        0. ],
       [0.2, 0.1, 0.1, 0. , 0. , 0.1, 0.1, 0. , 0.1, 0. , 0.6, 0. , 0.1,
        0.1],
       [0.1, 0.1, 0. , 0. , 0. , 0.1, 0. , 0. , 0. , 0. , 0. , 0.9, 0. ,
        0. ],
       [0.2, 0. , 0.2, 0.1, 0. , 0.1, 0.1, 0.1, 0. , 0.1, 0.1, 0. , 0.7,
        0. ],
       [0.2, 0.1, 0.1, 0. , 0. , 0.1, 0. , 0. , 0. , 0. , 0.1, 0. , 0. ,
        0.7]])</code></pre>
</div>
</div>
<ol start="2" type="1">
<li><strong>COVARIANCE MATRIX COMPUTATION</strong> The covariance matrix is simply to undestand how the variable of a dataset are varying from the mean with respect to each other <img src="../img/cov_matrix.png" class="img-fluid" data-fig-align="center"> I our matrix, we have the political parties on both side so the corelation matrix will shoe the corelation between each two political parties in the dataset</li>
</ol>
<div class="cell" data-execution_count="10">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Calculate the covariance matrix, eigenvalues and eigenvectors</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>covariance_matrix <span class="op">=</span> np.cov(matrix_array, rowvar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>covariance_matrix</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>array([[ 4.48901099e-02, -7.14285714e-03,  2.52197802e-02,
         8.73626374e-03, -1.81318681e-03, -4.50549451e-03,
         7.69230769e-03,  3.24175824e-03, -2.14285714e-03,
         1.09340659e-02,  7.52747253e-03, -5.05494505e-03,
         9.50549451e-03,  8.62637363e-03],
       [-7.14285714e-03,  5.03296703e-02, -8.02197802e-03,
        -1.40659341e-02,  1.40659341e-02, -1.31868132e-03,
         7.69230769e-04, -1.12087912e-02,  1.86813187e-03,
         3.29670330e-04,  4.39560440e-04,  2.19780220e-03,
        -1.25274725e-02,  1.86813187e-03],
       [ 2.52197802e-02, -8.02197802e-03,  4.99450549e-02,
         1.36813187e-02, -6.04395604e-04, -5.60439560e-03,
         2.40192481e-19,  2.15934066e-02, -2.25274725e-03,
         1.23626374e-02, -8.24175824e-04, -1.45054945e-02,
         1.13736264e-02,  5.49450549e-05],
       [ 8.73626374e-03, -1.40659341e-02,  1.36813187e-02,
         4.48901099e-02, -7.19780220e-03, -6.59340659e-04,
        -6.92307692e-03,  1.63186813e-02, -8.29670330e-03,
         5.54945055e-03, -7.85714286e-03, -8.90109890e-03,
         4.89010989e-03, -6.75824176e-03],
       [-1.81318681e-03,  1.40659341e-02, -6.04395604e-04,
        -7.19780220e-03,  3.56593407e-02, -7.80219780e-03,
        -4.61538462e-03, -4.78021978e-03, -4.78021978e-03,
        -3.24175824e-03, -5.21978022e-03, -4.94505495e-03,
        -7.19780220e-03, -4.01098901e-03],
       [-4.50549451e-03, -1.31868132e-03, -5.60439560e-03,
        -6.59340659e-04, -7.80219780e-03,  3.91208791e-02,
         2.30769231e-03, -7.47252747e-03,  2.52747253e-03,
        -7.47252747e-03,  2.08791209e-03,  2.74725275e-03,
         1.09890110e-04,  2.52747253e-03],
       [ 7.69230769e-03,  7.69230769e-04,  2.40192481e-19,
        -6.92307692e-03, -4.61538462e-03,  2.30769231e-03,
         2.46153846e-02, -5.38461538e-03,  4.61538462e-03,
        -3.84615385e-03,  4.61538462e-03, -6.15384615e-03,
         3.07692308e-03, -3.84615385e-03],
       [ 3.24175824e-03, -1.12087912e-02,  2.15934066e-02,
         1.63186813e-02, -4.78021978e-03, -7.47252747e-03,
        -5.38461538e-03,  2.99450549e-02, -6.20879121e-03,
        -8.24175824e-04, -6.09890110e-03, -7.80219780e-03,
         5.54945055e-03, -5.43956044e-03],
       [-2.14285714e-03,  1.86813187e-03, -2.25274725e-03,
        -8.29670330e-03, -4.78021978e-03,  2.52747253e-03,
         4.61538462e-03, -6.20879121e-03,  3.30219780e-02,
        -5.43956044e-03,  3.90109890e-03, -6.26373626e-03,
        -6.75824176e-03, -4.67032967e-03],
       [ 1.09340659e-02,  3.29670330e-04,  1.23626374e-02,
         5.54945055e-03, -3.24175824e-03, -7.47252747e-03,
        -3.84615385e-03, -8.24175824e-04, -5.43956044e-03,
         2.68681319e-02, -4.56043956e-03, -6.26373626e-03,
         4.78021978e-03, -3.90109890e-03],
       [ 7.52747253e-03,  4.39560440e-04, -8.24175824e-04,
        -7.85714286e-03, -5.21978022e-03,  2.08791209e-03,
         4.61538462e-03, -6.09890110e-03,  3.90109890e-03,
        -4.56043956e-03,  2.37912088e-02, -6.81318681e-03,
         2.14285714e-03,  4.67032967e-03],
       [-5.05494505e-03,  2.19780220e-03, -1.45054945e-02,
        -8.90109890e-03, -4.94505495e-03,  2.74725275e-03,
        -6.15384615e-03, -7.80219780e-03, -6.26373626e-03,
        -6.26373626e-03, -6.81318681e-03,  5.67032967e-02,
        -8.90109890e-03, -5.49450549e-03],
       [ 9.50549451e-03, -1.25274725e-02,  1.13736264e-02,
         4.89010989e-03, -7.19780220e-03,  1.09890110e-04,
         3.07692308e-03,  5.54945055e-03, -6.75824176e-03,
         4.78021978e-03,  2.14285714e-03, -8.90109890e-03,
         3.25824176e-02, -5.98901099e-03],
       [ 8.62637363e-03,  1.86813187e-03,  5.49450549e-05,
        -6.75824176e-03, -4.01098901e-03,  2.52747253e-03,
        -3.84615385e-03, -5.43956044e-03, -4.67032967e-03,
        -3.90109890e-03,  4.67032967e-03, -5.49450549e-03,
        -5.98901099e-03,  3.45604396e-02]])</code></pre>
</div>
</div>
<ol start="3" type="1">
<li><p>FEATURE VECTOR (EIGENVALUES &amp; EIGENVECTORS) EigenVectors and EignValues are the features we need form the covariance matrix in order for us to comput the principal components. The EigneVectors and EigenValues comes in pair, so for an N*N matrix, there are N Eignevector and N Eigenvalues. The Eigenvalue is the maginitude while the Eigenvectors od the covariance matrix show the direction of the axes with the most variance which translate to the principal component <img src="../img/eigenvector_decomposition.png" class="img-fluid" data-fig-align="center"></p>
<p>For a square matrix A, an Eigenvector and Eigenvalue make this equation true: Mathematically, $$ Av = λv</p>
<p>Av = λvI ; I is an Identity Matrix</p>
<p>Av - λvI = 0</p>
<p>If v is non - zero;</p>
<p>|A-λI| = 0 $$</p></li>
</ol>
<div class="cell" data-execution_count="11">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eig(covariance_matrix)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Make a list of (eigenvalue, eigenvector) tuples</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>eig_pairs <span class="op">=</span> [(np.<span class="bu">abs</span>(eigenvalues[i]), eigenvectors[:, i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(eigenvalues))]</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>eig_pairs.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>eig_pairs[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>(0.11683748069795084,
 array([ 0.37048005, -0.32232622,  0.52163899,  0.37881807, -0.11502078,
        -0.10964456,  0.00066325,  0.32393686, -0.09908774,  0.19222008,
        -0.01131912, -0.30828853,  0.26581997, -0.02134495]))</code></pre>
</div>
</div>
<p>The first Principal Component is the EigenVector corresponding to the highest Eigen values, and the second component is the second eigenvectore and so on. so now that we’ve attain out component, we will go ahead and visual them # RESULTS ## PCA</p>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------------</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Party names, labels, total votes, and colors for the visualization</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>bremen_2011_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2011_party_percentages.pkl"</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>bre_2011_label_votes <span class="op">=</span> bremen_2011_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>bremen_2015_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2015_party_percentages.pkl"</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>bre_2015_label_votes <span class="op">=</span> bremen_2015_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>bremen_2019_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2019_party_percentages.pkl"</span>)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>bre_2019_label_votes <span class="op">=</span> bremen_2019_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>bremen_2023_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2023_party_percentages.pkl"</span>)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>bre_2023_label_votes <span class="op">=</span> bremen_2023_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="13">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perform_pca_new(matrix_df, labels_df, n_components<span class="op">=</span><span class="dv">2</span>, title<span class="op">=</span><span class="st">'PCA Result'</span>):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert dataframe to NumPy array</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    matrix_array <span class="op">=</span> matrix_df.to_numpy()</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the covariance matrix</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    covariance_matrix <span class="op">=</span> np.cov(matrix_array, rowvar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute eigenvalues and eigenvectors</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eig(covariance_matrix)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort eigenvectors based on eigenvalues</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    sorted_indices <span class="op">=</span> np.argsort(eigenvalues)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    topk_indices <span class="op">=</span> sorted_indices[:n_components]</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select the top-k eigenvectors</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    selected_eigenvectors <span class="op">=</span> eigenvectors[:, topk_indices]</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract labels and sizes from the labels DataFrame</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels_df[<span class="st">'Kurzform'</span>].tolist()</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    sizes <span class="op">=</span> np.sqrt(labels_df[<span class="st">'total_count'</span>]).tolist() </span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> labels_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>).tolist()  <span class="co"># Replace NaN with 'grey'</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot PCA result with adjusted point sizes and labels</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (label, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(labels, colors)):</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        plt.scatter(eigenvectors[i, <span class="dv">0</span>], eigenvectors[i, <span class="dv">1</span>], s<span class="op">=</span>sizes[i], color<span class="op">=</span>color)</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        plt.annotate(label, (eigenvectors[i, <span class="dv">0</span>], eigenvectors[i, <span class="dv">1</span>]))</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot PCA result</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plt.scatter(eigenvectors[:, 0], eigenvectors[:, 1])</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Principal Component 1'</span>)</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Principal Component 2'</span>)</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot each PCA result</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2011, bre_2011_label_votes, title<span class="op">=</span><span class="st">'Bremen 2011 - Average Co-voter percentages'</span>)</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2015, bre_2015_label_votes, title<span class="op">=</span><span class="st">'Bremen 2015 - Average Co-voter percentages'</span>)</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a><span class="co">#perform_pca_new(matrix_bre_2019, bre_2019_label_votes, title='Bremen 2019 - Average Co-voter percentages')</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2023, bre_2023_label_votes, title<span class="op">=</span><span class="st">'Bremen 2023 - Average Co-voter percentages'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-14-output-1.png" width="755" height="566"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-14-output-2.png" width="756" height="566"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-14-output-3.png" width="756" height="566"></p>
</div>
</div>
<p>In the figues above, I have represent in two dimensions (2D) the first two principal components of the avaerage percentages co-voters showing the display of the political parties thath participated in that year’s elections. Since PCA reprensents our data with respect to maximum variance, we deduced that pricipal component one shows the highest variance of between the parties following bay principal component two. In describing political parties, several characteristics can be use such as size of the party, demopharaphics, wing, Geographical base, etc. We will use some of these measure to interpret our figures.</p>
<p>In the first figure, <em>Bremen 2011 - Average Co-voter percentages</em>, one can characerize the first principal componet as the wing of the parties as we see alomost a clear distintion of the parties on opposite wings, most notable is the left(Die Linke) which is a popalr far left pary on the far positve end of our x-axis and NPD on the far negative end of the x-axis. The second principal component can be used to describe the size of the parties are we see the biggest parties towards the bottom and smaller parties above them.</p>
<p>In the Second figure, <em>Bremen 201 - Average Co-voter percentages</em>, we can again characerize the first principal componet as the wing of the parties as we see alomost a clear distintion of the parties on opposite wings, most notable is the left(Die Linke) and Grüne which is a popalr far left pary on the far negative end of our x-axis and AFD and BIW on the far positive end of the x-axis, this is in contrast to the first figure where the positve end of the x-axis was the left wing parties and the negative is the right wing parties. The second principal component can be used to describe the size of the parties are we see the biggest parties.</p>
<p>In the third figure, <em>Bremen 2023 - Average Co-voter percentages</em>, just like the first one, the first principal componet can be characterized as the wing of the parties as we see alomost a clear distintion of the parties on opposite wings, most notable is the left(Die Linke) which is a popalr far left pary on the far positve end of our x-axis and BIW on the far negative end of the x-axis. The second principal component can be used to describe the popularity of the parties are we see the biggest parties.</p>
<p>Now lets display the principal components of the Ratio between the union and the intersection</p>
<div class="cell" data-execution_count="14">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2011_ratio, bre_2011_label_votes, title<span class="op">=</span><span class="st">'Bremen Voter Ratio 2011'</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2015_ratio, bre_2015_label_votes, title<span class="op">=</span><span class="st">'Bremen Voter Ratio 2015'</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">#perform_pca_new(matrix_bre_2019_ratio, bre_2019_label_votes, title='Bremen Voter Ratio 2019')</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2023_ratio, bre_2023_label_votes, title<span class="op">=</span><span class="st">'Bremen Voter Ratio 2023'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-15-output-1.png" width="758" height="566"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-15-output-2.png" width="758" height="566"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-15-output-3.png" width="758" height="566"></p>
</div>
</div>
<p>The first figure titled <em>Bremen Voter Ratio 2011</em> shows an interesting display of paties in 2D. I can see the largest parties like SPD, CDU and GRÜNE clustered around the far positive end of the first principal component, so I can deduce that it reprent the size of the parties. The second component with CDU isolated at the bottom of the chart, one could deduce that this component can describe the demographic appeal of the party be cause CDU is know for it traditional norms, and voter concentration higher in older people in rural area rather than urban areas unlike SPD wich is in the opposite side of the chart known for being a party of the working class and trade uinions. In the second Figure, <em>Bremen Voter Ratio 2015</em> very much similar to the first one, we can describe the forst principle as the size of the political party with the biggest parties like SPD, CDU, GRÜNE and Die Linke all situated on the far right of the first principal component. the second component again can be used to describe the demographic appeal of the party. The third figure has rhe same interpretation as the previous ones.</p>
</section>
</section>
</section>
<section id="muti-dimensional-scaling" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="muti-dimensional-scaling"><span class="header-section-number">3.6</span> Muti Dimensional Scaling</h2>
<p><strong>Multidimensional scaling (MDS)</strong> is a non-linear dimensionality reduction method to extract a lower-dimensional configuration from the measurement of pairwise distances (dissimilarities) between the points in a dataset. #### Steps to calculate MDS</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> MDS</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_mds_with_labels_and_sizes(matrix_df, labels_df, title<span class="op">=</span><span class="st">'MDS Result'</span>):</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert dataframe to NumPy array and scale it</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    matrix_array <span class="op">=</span> matrix_df.to_numpy()</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>   <span class="co"># matrix_array = scale(matrix_array)</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform MDS</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    mds <span class="op">=</span> MDS(n_components<span class="op">=</span><span class="dv">2</span>, dissimilarity<span class="op">=</span><span class="st">'precomputed'</span>)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    mds_result <span class="op">=</span> mds.fit_transform(matrix_array)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract labels, sizes, and colors from the labels DataFrame</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels_df[<span class="st">'Kurzform'</span>].tolist()</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    sizes <span class="op">=</span> np.sqrt(labels_df[<span class="st">'total_count'</span>]).tolist()</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> labels_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>).tolist()  <span class="co"># Replace NaN with 'grey'</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot MDS result with adjusted point sizes and colors</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (label, size, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(labels, sizes, colors)):</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>        plt.scatter(mds_result[i, <span class="dv">0</span>], mds_result[i, <span class="dv">1</span>], s<span class="op">=</span>size, color<span class="op">=</span>color)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>        plt.annotate(label, (mds_result[i, <span class="dv">0</span>], mds_result[i, <span class="dv">1</span>]))</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set plot title and labels</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'MDS Dimension 1'</span>)</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'MDS Dimension 2'</span>)</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show plot</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2011, bre_2011_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2011'</span>)</span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2015, bre_2015_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2015'</span>)</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2019, bre_2019_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2019'</span>)</span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2023, bre_2023_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2023'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\manja\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\manifold\_mds.py:299: FutureWarning:

The default value of `normalized_stress` will change to `'auto'` in version 1.4. To suppress this warning, manually set the value of `normalized_stress`.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-16-output-2.png" width="758" height="566"></p>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\manja\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\manifold\_mds.py:299: FutureWarning:

The default value of `normalized_stress` will change to `'auto'` in version 1.4. To suppress this warning, manually set the value of `normalized_stress`.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-16-output-4.png" width="757" height="566"></p>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\manja\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\manifold\_mds.py:299: FutureWarning:

The default value of `normalized_stress` will change to `'auto'` in version 1.4. To suppress this warning, manually set the value of `normalized_stress`.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-16-output-6.png" width="756" height="566"></p>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\manja\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\manifold\_mds.py:299: FutureWarning:

The default value of `normalized_stress` will change to `'auto'` in version 1.4. To suppress this warning, manually set the value of `normalized_stress`.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-16-output-8.png" width="758" height="566"></p>
</div>
</div>
<section id="interpretaion-of-the-figures" class="level4" data-number="3.6.0.1">
<h4 data-number="3.6.0.1" class="anchored" data-anchor-id="interpretaion-of-the-figures"><span class="header-section-number">3.6.0.1</span> Interpretaion of the figures</h4>
</section>
</section>
<section id="tsne" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="tsne"><span class="header-section-number">3.7</span> TSNE</h2>
<p><strong>Stochastic neighbor embedding (SNE)</strong> is a probabilistic approach to dimensional reduction that places data points in high dimensional space into low dimensional space while preserving the identity of neighbors. That is, SNE attempts to keep nearby data points nearby, and separated data points relatively far apart. It tries to keep the data clusters together but relative distance/ arrangement of different clusters can change.</p>
<p>Gaussian distribution is applied to each data point in P and Q subspace</p>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perform_and_plot_tsne(matrix_df, labels_df,labels<span class="op">=</span><span class="va">None</span>, random_state<span class="op">=</span><span class="dv">0</span>, n_components<span class="op">=</span><span class="dv">2</span>, perplexity<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>                          learning_rate<span class="op">=</span><span class="st">"auto"</span>, title<span class="op">=</span><span class="st">'t-SNE Result'</span>):</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert dataframe to NumPy array</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    matrix_array <span class="op">=</span> matrix_df.to_numpy()</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform t-SNE</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    tsne <span class="op">=</span> TSNE(n_components<span class="op">=</span>n_components, perplexity<span class="op">=</span>perplexity, learning_rate<span class="op">=</span>learning_rate, random_state<span class="op">=</span>random_state)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    tsne_result <span class="op">=</span> tsne.fit_transform(matrix_array)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract labels, sizes, and colors from the labels DataFrame</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels_df[<span class="st">'Kurzform'</span>].tolist()</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    sizes <span class="op">=</span> np.sqrt(labels_df[<span class="st">'total_count'</span>]).tolist()</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> labels_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>).tolist()  <span class="co"># Replace NaN with 'grey'</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot MDS result with adjusted point sizes and colors</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (label, size, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(labels, sizes, colors)):</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>        plt.scatter(tsne_result[i, <span class="dv">0</span>], tsne_result[i, <span class="dv">1</span>], s<span class="op">=</span>size, color<span class="op">=</span>color)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        plt.annotate(label, (tsne_result[i, <span class="dv">0</span>], tsne_result[i, <span class="dv">1</span>]))</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Component 1'</span>)</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Component 2'</span>)</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2011, bre_2011_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2011'</span>)</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2015, bre_2015_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2015'</span>)</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2019, bre_2019_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2019'</span>)</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2023, bre_2023_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2023'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-17-output-1.png" width="756" height="566"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-17-output-2.png" width="758" height="566"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-17-output-3.png" width="758" height="566"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="notes_files/figure-html/cell-17-output-4.png" width="758" height="566"></p>
</div>
</div>
</section>
</section>
<section id="discusion" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Discusion</h1>
</section>
<section id="references" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> REFERENCES</h1>
<!-- -->

</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb33" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "The Political Landscape of Bremen, A Data Science Approach"</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="an">Author:</span><span class="co"> "Modou Lamin Manjang"</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true                   # This creates the table of context menu</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 2                # Increase if you want to have subsections in the table of context menu</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="co">    number-sections: true</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="co">#bibliography: ''</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="fu"># Abstract</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>The objective of this master’s thesis is to conduct a thorough and systematic analysis of political party preferences in Bremen across the last four electoral cycles, employing advanced data science methods.  The study captures and visualizes the correlations between political parties based on voting data using dimensionality reduction techniques such as Principal Component Analysis (PCA), Multidimensional Scaling (MDS), and t-Distributed Stochastic Neighbor Embedding (t-SNE). The datasets for these models were generated using two different methods: the first builds a matrix from the percentages of co-voters for each pair of political parties, and the second computes the ratio of the union to the intersection of co-voters. These approaches provide a comprehensive view of voter base overlaps and the relative breadth of party support. The application of PCA, MDS, and t-SNE to these datasets reveals underlying patterns and shifts in political alignment among voters. The findings of this study offer novel and significant insights into the development and transformation of the political landscape in Bremen, highlighting trends and relationships that may not be apparent through traditional analysis methods.</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span class="fu">## Background and Motivation</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>Bremen is a city-state in Germany with a long and rich history of political participation and diversity. It is the smallest and oldest of the 16 federal states, with a population of about 680,000 and an area of 419 km². It consists of two major cities, Bremen and Bremerhaven, which are separated by 60 km of Lower Saxony. Bremen is known for its maritime economy, cultural heritage, and cosmopolitan outlook, while Bremerhaven is a major port and a center of scientific research.</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>The political landscape of Bremen reflects its unique and dynamic character. It has been a stronghold of the Social Democratic Party (SPD), a center-left party, since 1946. The SPD has historically been influential in shaping the state's policies and governance. On the left of the political spectrum, Bremen has also seen the presence of the Left Party (Die Linke), representing far-left ideologies and advocating for more radical changes in social and economic policies.On the right of the spectrum, the Christian Democratic Union (CDU) has been a significant political force, representing center-right to right-wing views with a focus on conservative values and market-oriented policies. The Free Democratic Party (FDP), which also aligns with center-right ideologies, advocates for economic liberalism and individual freedoms.</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>In recent years, the political landscape has become more fragmented with the rise of new parties. The Green Party (Die Grünen), positioned on the left, emphasizes environmental issues, social justice, and sustainable development. On the far-right, the Alternative for Germany (AfD) has gained prominence, advocating for nationalist and anti-immigration policies. The Citizens in Rage (BiW) is another right-wing party that has emerged, often focusing on local issues and expressing populist sentiments.</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>Elections in Bremen, like in other historic cities, are influenced by various factors such as economic conditions, social issues, media coverage, and voter turnout. The results of these elections have significant implications for governance, policies, and representation at the state level, as well as for Bremen's relations with the federal government and other states.</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>The motivation for this study stems from a desire to extend the use of data science and machine learning beyond their traditional applications in pure sciences, exploring their potential in the social sciences. Analyzing the political landscape using advanced data science techniques offers an intriguing opportunity to gain new insights into voter behavior and party dynamics. By applying methods such as *Principal Component Analysis (PCA)*, *Multidimensional Scaling (MDS)*, and *t-Distributed Stochastic Neighbor Embedding (t-SNE)* to the Bremen election data, this study aims to uncover patterns and allign parties in a two dimensional scalling </span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>This study will employ dimensionality reduction techniques to create visual representations of political party relationships based on voter data. The datasets for these models are constructed using two approaches: one based on the percentages of co-voters for each pair of political parties, and the other on the ratio of the union to the intersection of co-voters. These methods provide a nuanced view of voter base overlaps and the relative breadth of party support.</span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>The results of this analysis are expected to contribute valuable insights into the evolving political landscape of Bremen, highlighting trends and relationships that could inform future electoral strategies and political understanding. By venturing into the realm of social science through the lens of data science, this study aims to demonstrate the versatility and applicability of machine learning techniques in understanding complex societal phenomena.</span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## Research Question</span></span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>How have the voting patterns for political parties in Bremen evolved over the past four electoral cycles?</span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>How much is the voter trend changing in Bremen over the last four (4) elections and what doe this signify for Bremen as a state?</span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>Can dimensionality reduction techniques (PCA, MDS, and T-SNE) reveal any significant shifts or trends in the political landscape of Bremen?</span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a><span class="fu">### Significance of the studies</span></span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>Understanding the political landscape of Bremen through a data science lens holds immense significance for various reasons. Firstly, this study has the potential to unveil the intricate changes in voters' preferences and behaviors over time. By employing advanced data science techniques, such as Principal Component Analysis (PCA), Multidimensional Scaling (MDS), and t-Distributed Stochastic Neighbor Embedding (t-SNE), the analysis can identify patterns and trends in voting behavior, shedding light on the factors that have influenced these shifts. Unraveling the dynamics of voter preferences is crucial for fostering a deeper comprehension of the democratic processes within the region.</span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a>Secondly, the study aims to explore how political parties in Bremen, spanning the political spectrum from the far-left (Die Linke) to the far-right (AfD), as well as center-left (SPD) and center-right (CDU, FDP) parties, have adapted their strategies and policies in response to the evolving electoral landscape. Investigating the challenges faced by these political entities allows for a nuanced understanding of the strategies that proved successful and those that were less effective. This knowledge can be instrumental for both political practitioners and researchers, providing insights into the adaptive capabilities of political organizations in a dynamic environment.</span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>Moreover, the study will consider the size and influence of these parties. By analyzing large, established parties like the SPD and CDU alongside smaller or emerging parties like the Greens, AfD, and BiW, the research can highlight differences in their voter bases, policy impacts, and strategic adaptations. This comprehensive view contributes to a richer understanding of the political ecosystem in Bremen.</span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>Furthermore, the analysis of political outcomes and their impact on governance, development, and representation in Bremen at the state and federal levels is of paramount importance. Understanding how shifts in political power translate into tangible effects on governance and development helps policymakers anticipate and respond to emerging trends. It also provides an opportunity to identify risks and opportunities associated with different political scenarios, offering valuable insights for proactive decision-making.</span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a>Beyond its local implications, the study significantly advances the broader literature on political analysis. The application of advanced data science techniques, including machine learning models and statistical measures, to the analysis of complex and dynamic political data is a novel contribution. By demonstrating the efficacy of these methods in a real-world political context, the study enriches the toolkit available for political scientists and data analysts alike, paving the way for innovative approaches in future research endeavors.</span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-54"><a href="#cb33-54" aria-hidden="true" tabindex="-1"></a>Moreover, the study enables a comparative analysis of different methods and tools for political analysis, evaluating their respective strengths and limitations. This comparative aspect is crucial for advancing the field, guiding researchers and practitioners towards the most effective approaches based on the specific nuances of their data and research questions.</span>
<span id="cb33-55"><a href="#cb33-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-56"><a href="#cb33-56" aria-hidden="true" tabindex="-1"></a>Lastly, effective communication and dissemination of findings are vital aspects of the study. Understanding how to convey complex political insights derived from data science methodologies to diverse audiences and stakeholders ensures the practical utility of the research. The study will contribute to the development of effective communication strategies, facilitating the translation of data-driven political analyses into actionable information for policymakers, political actors, and the public. This will help bridge the gap between complex data science techniques and practical political applications, ensuring that the insights gained are accessible and impactful.</span>
<span id="cb33-57"><a href="#cb33-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-58"><a href="#cb33-58" aria-hidden="true" tabindex="-1"></a><span class="fu">## Literature Review</span></span>
<span id="cb33-59"><a href="#cb33-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-60"><a href="#cb33-60" aria-hidden="true" tabindex="-1"></a>The analysis of election data has become increasingly vital in understanding the dynamics of political landscapes, voter behaviors, and party strategies.</span>
<span id="cb33-61"><a href="#cb33-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-62"><a href="#cb33-62" aria-hidden="true" tabindex="-1"></a>Temporal analysis of election data has been a recurrent theme in the literature, with researchers employing diverse statistical techniques to unravel the changing preferences of voters over time. Studies such as (Bowler et al., 2018) and (Exploring the Political Pulse of a Country Using Data Science Tools | Journal of Computational Social Science, n.d.) have applied time series analysis to model the evolution of voter sentiment, identifying critical factors influencing shifts in electoral preferences.</span>
<span id="cb33-63"><a href="#cb33-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-64"><a href="#cb33-64" aria-hidden="true" tabindex="-1"></a>Understanding the ramifications of election outcomes on governance, development, and representation has garnered attention in the literature. Notable studies, such as (Kellermann, 2023) delve into the practical implications of political shifts, exploring how changes in power dynamics influence policy decisions, public services, and overall governance. The integration of advanced data science techniques into political analysis represents a growing trend. Works by (Aramburo et al., 2022) showcase the application of machine learning models and statistical measures, such as sentiment analysis to discern complex patterns within election data. These studies contribute to the evolving methodology in political science research, opening avenues for more nuanced analyses.</span>
<span id="cb33-65"><a href="#cb33-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-66"><a href="#cb33-66" aria-hidden="true" tabindex="-1"></a>Effectively communicating complex political insights derived from data science methodologies is a crucial aspect explored in the literature. Studies, such as (Exploring the Political Pulse of a Country Using Data Science Tools | Journal of Computational Social Science, n.d.), focus on developing communication strategies that bridge the gap between technical analyses and the comprehension of diverse audiences, including policymakers, political actors, and the general public.</span>
<span id="cb33-67"><a href="#cb33-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-68"><a href="#cb33-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-69"><a href="#cb33-69" aria-hidden="true" tabindex="-1"></a><span class="fu"># Methodology </span></span>
<span id="cb33-70"><a href="#cb33-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-71"><a href="#cb33-71" aria-hidden="true" tabindex="-1"></a><span class="fu">## Data Collection &amp; processing</span></span>
<span id="cb33-72"><a href="#cb33-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-73"><a href="#cb33-73" aria-hidden="true" tabindex="-1"></a>In order to conduct a comprehensive study on the political landscape of Bremen, election data has been sourced directly from the Statistisches Landesamt Bremen. As the mandated legal body responsible for the management and storage of election data in Bremen, Statistisches Landesamt plays a pivotal role in ensuring the accuracy, integrity, and accessibility of electoral information. By collaborating with this authoritative institution, the study ensures access to a reliable and official dataset, providing a solid foundation for the ensuing data science analysis. The utilization of data curated and maintained by Statistisches Landesamt Bremen not only enhances the credibility of the research findings but also underscores the commitment to adhering to legal and ethical standards in acquiring and utilizing electoral data for academic purposes. This collaboration reinforces the study's dedication to conducting rigorous and responsible research on the political dynamics of Bremen.</span>
<span id="cb33-74"><a href="#cb33-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-75"><a href="#cb33-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-76"><a href="#cb33-76" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Five-Vote System in Germany</span></span>
<span id="cb33-77"><a href="#cb33-77" aria-hidden="true" tabindex="-1"></a>In Germany, the electoral system used for federal elections is a mixed-member proportional representation system.  Each voter has two votes: the first for an individual constituency candidate, and the second for a party-list in a particular state/Land (The Voting System, n.d.). Voters receive a ballot paper that allows them to cast two votes, referred to as the "first vote" (Erststimme) and the "second vote" (Zweitstimme). This system is designed to combine the benefits of direct and proportional representation. Here's a brief overview of how the ballot works and how the data is collected.</span>
<span id="cb33-78"><a href="#cb33-78" aria-hidden="true" tabindex="-1"></a><span class="al">![](../img/Stimmzettel_HB-BB_2023.jpeg)</span>{fig-align="center"}</span>
<span id="cb33-79"><a href="#cb33-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-80"><a href="#cb33-80" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Ballot Paper</span></span>
<span id="cb33-81"><a href="#cb33-81" aria-hidden="true" tabindex="-1"></a>The German ballot paper is divided into two sections:</span>
<span id="cb33-82"><a href="#cb33-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-83"><a href="#cb33-83" aria-hidden="true" tabindex="-1"></a>First Vote (Erststimme):</span>
<span id="cb33-84"><a href="#cb33-84" aria-hidden="true" tabindex="-1"></a>This vote is cast for a direct candidate in the voter's constituency. The candidate with the most votes in each constituency wins a seat in the Bundestag (Germany's federal parliament).</span>
<span id="cb33-85"><a href="#cb33-85" aria-hidden="true" tabindex="-1"></a>Each candidate is identified by a unique code. The last two digits of this code represent the candidate number, while the first two digits represent the party affiliation.</span>
<span id="cb33-86"><a href="#cb33-86" aria-hidden="true" tabindex="-1"></a>Second Vote (Zweitstimme):</span>
<span id="cb33-87"><a href="#cb33-87" aria-hidden="true" tabindex="-1"></a>This vote is cast for a political party. It determines the overall proportion of seats each party will receive in the Bundestag.</span>
<span id="cb33-88"><a href="#cb33-88" aria-hidden="true" tabindex="-1"></a>The second vote is crucial because it decides the total representation of parties in parliament.</span>
<span id="cb33-89"><a href="#cb33-89" aria-hidden="true" tabindex="-1"></a><span class="fu">#### </span></span>
<span id="cb33-90"><a href="#cb33-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-91"><a href="#cb33-91" aria-hidden="true" tabindex="-1"></a>During the election, votes are collected and recorded with specific codes that identify both the party and the candidate. For instance:</span>
<span id="cb33-92"><a href="#cb33-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-93"><a href="#cb33-93" aria-hidden="true" tabindex="-1"></a>First Vote (Erststimme) Data:</span>
<span id="cb33-94"><a href="#cb33-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-95"><a href="#cb33-95" aria-hidden="true" tabindex="-1"></a>A code like 0101 might represent a candidate from Party 01 (e.g., SPD) who is candidate number 01 in that party.</span>
<span id="cb33-96"><a href="#cb33-96" aria-hidden="true" tabindex="-1"></a>0202 could represent a candidate from Party 02 (e.g., CDU) who is candidate number 02 in that party.</span>
<span id="cb33-97"><a href="#cb33-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-98"><a href="#cb33-98" aria-hidden="true" tabindex="-1"></a>Second Vote (Zweitstimme) Data:</span>
<span id="cb33-99"><a href="#cb33-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-100"><a href="#cb33-100" aria-hidden="true" tabindex="-1"></a>Votes are recorded for the parties based on the proportional representation system.</span>
<span id="cb33-101"><a href="#cb33-101" aria-hidden="true" tabindex="-1"></a>A code like 01 would count as a vote for Party 01 (SPD).</span>
<span id="cb33-102"><a href="#cb33-102" aria-hidden="true" tabindex="-1"></a>02 would count as a vote for Party 02 (CDU).</span>
<span id="cb33-103"><a href="#cb33-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-104"><a href="#cb33-104" aria-hidden="true" tabindex="-1"></a>The data collected from the ballots is processed to understand voting patterns and party preferences. Each vote is logged with the relevant codes, and this information is aggregated to analyze the overall electoral outcomes.</span>
<span id="cb33-105"><a href="#cb33-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-106"><a href="#cb33-106" aria-hidden="true" tabindex="-1"></a>Consider the following data records from an election:</span>
<span id="cb33-107"><a href="#cb33-107" aria-hidden="true" tabindex="-1"></a>** 0101, 0102, 0201, 0301, 0401 **</span>
<span id="cb33-108"><a href="#cb33-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-109"><a href="#cb33-109" aria-hidden="true" tabindex="-1"></a>These records indicate that the voters chose candidates and parties as follows:</span>
<span id="cb33-110"><a href="#cb33-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-111"><a href="#cb33-111" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Voter 1 chose candidate 01 from Party 01 (SPD) and Party 01 (SPD) for the second vote.</span>
<span id="cb33-112"><a href="#cb33-112" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Voter 2 chose candidate 02 from Party 01 (SPD) and Party 02 (CDU) for the second vote.</span>
<span id="cb33-113"><a href="#cb33-113" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Voter 3 chose candidate 01 from Party 02 (CDU) and Party 03 (Greens) for the second vote.</span>
<span id="cb33-114"><a href="#cb33-114" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Voter 4 chose candidate 01 from Party 03 (Greens) and Party 01 (SPD) for the second vote.</span>
<span id="cb33-115"><a href="#cb33-115" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Voter 5 chose candidate 01 from Party 04 (FDP) and Party 04 (FDP) for the second vote.</span>
<span id="cb33-116"><a href="#cb33-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-117"><a href="#cb33-117" aria-hidden="true" tabindex="-1"></a>NB: These partyy codes like 01 for SPD are not static, the change in every election cycle based on the performance of the parties in the privous elections and some other factors.</span>
<span id="cb33-118"><a href="#cb33-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-119"><a href="#cb33-119" aria-hidden="true" tabindex="-1"></a>This dual voting system allows for a nuanced representation of voter preferences, balancing direct candidate support with proportional party representation. </span>
<span id="cb33-120"><a href="#cb33-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-121"><a href="#cb33-121" aria-hidden="true" tabindex="-1"></a><span class="fu">## Data Preprocessing</span></span>
<span id="cb33-122"><a href="#cb33-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-123"><a href="#cb33-123" aria-hidden="true" tabindex="-1"></a>To analyze the political landscape of Bremen using dimensionality reduction techniques such as PCA, MDS, and T-SNE, we prepared our datasets with a focus on voter behavior patterns. The raw data from the <span class="al">![](../img/stmme.png)</span>{fig-align="center"}</span>
<span id="cb33-124"><a href="#cb33-124" aria-hidden="true" tabindex="-1"></a>The goal was to transform the raw voting data into a format suitable for these techniques, capturing the relationships between political parties in a meaningful way. Two distinct approaches were used to create our datasets, ensuring a comprehensive analysis.</span>
<span id="cb33-125"><a href="#cb33-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-126"><a href="#cb33-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-127"><a href="#cb33-127" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo = FALSE}</span></span>
<span id="cb33-128"><a href="#cb33-128" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb33-129"><a href="#cb33-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-130"><a href="#cb33-130" aria-hidden="true" tabindex="-1"></a>party_codes <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Parteien-Codes.xlsx"</span>)</span>
<span id="cb33-131"><a href="#cb33-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-132"><a href="#cb33-132" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_unique_numbers(df):</span>
<span id="cb33-133"><a href="#cb33-133" aria-hidden="true" tabindex="-1"></a>  df <span class="op">=</span> df.astype(<span class="bu">int</span>)</span>
<span id="cb33-134"><a href="#cb33-134" aria-hidden="true" tabindex="-1"></a>  unique_counts <span class="op">=</span> {}</span>
<span id="cb33-135"><a href="#cb33-135" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb33-136"><a href="#cb33-136" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> value <span class="kw">in</span> row:</span>
<span id="cb33-137"><a href="#cb33-137" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> value <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb33-138"><a href="#cb33-138" aria-hidden="true" tabindex="-1"></a>              unique_counts[value] <span class="op">=</span> unique_counts.get(value, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb33-139"><a href="#cb33-139" aria-hidden="true" tabindex="-1"></a>  unique_counts_df <span class="op">=</span> pd.DataFrame(<span class="bu">list</span>(unique_counts.items()), columns<span class="op">=</span>[<span class="st">'Number'</span>, <span class="st">'Count'</span>])</span>
<span id="cb33-140"><a href="#cb33-140" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> unique_counts_df</span>
<span id="cb33-141"><a href="#cb33-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-142"><a href="#cb33-142" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_hundredth(number):</span>
<span id="cb33-143"><a href="#cb33-143" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (number <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span><span class="dv">100</span></span>
<span id="cb33-144"><a href="#cb33-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-145"><a href="#cb33-145" aria-hidden="true" tabindex="-1"></a><span class="co">#Merged with party code</span></span>
<span id="cb33-146"><a href="#cb33-146" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> party_percentage_dist(df, party_codes, year, district):</span>
<span id="cb33-147"><a href="#cb33-147" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Merge with the party code</span></span>
<span id="cb33-148"><a href="#cb33-148" aria-hidden="true" tabindex="-1"></a>    unique_counts_df <span class="op">=</span> count_unique_numbers(df)</span>
<span id="cb33-149"><a href="#cb33-149" aria-hidden="true" tabindex="-1"></a>    unique_counts_df[<span class="st">'party_id'</span>] <span class="op">=</span> unique_counts_df[<span class="st">'Number'</span>].<span class="bu">apply</span>(get_hundredth)</span>
<span id="cb33-150"><a href="#cb33-150" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-151"><a href="#cb33-151" aria-hidden="true" tabindex="-1"></a>    party_votes <span class="op">=</span> unique_counts_df.groupby(<span class="st">'party_id'</span>)[<span class="st">'Count'</span>].<span class="bu">sum</span>().reset_index()</span>
<span id="cb33-152"><a href="#cb33-152" aria-hidden="true" tabindex="-1"></a>    party_votes.columns <span class="op">=</span> [<span class="st">'party_id'</span>, <span class="st">'total_count'</span>]</span>
<span id="cb33-153"><a href="#cb33-153" aria-hidden="true" tabindex="-1"></a>    total_votes <span class="op">=</span> party_votes[<span class="st">'total_count'</span>].<span class="bu">sum</span>()</span>
<span id="cb33-154"><a href="#cb33-154" aria-hidden="true" tabindex="-1"></a>    party_votes[<span class="st">'percentage %'</span>] <span class="op">=</span> ((party_votes[<span class="st">'total_count'</span>] <span class="op">/</span> total_votes) <span class="op">*</span> <span class="dv">100</span>).<span class="bu">round</span>(<span class="dv">2</span>)</span>
<span id="cb33-155"><a href="#cb33-155" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-156"><a href="#cb33-156" aria-hidden="true" tabindex="-1"></a>    party_codes <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> year) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> district)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb33-157"><a href="#cb33-157" aria-hidden="true" tabindex="-1"></a>    merged_df <span class="op">=</span> pd.merge(party_votes, party_codes, how<span class="op">=</span><span class="st">'inner'</span>, on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb33-158"><a href="#cb33-158" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-159"><a href="#cb33-159" aria-hidden="true" tabindex="-1"></a>    <span class="co">#table_party = tabulate(merged_df, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb33-160"><a href="#cb33-160" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merged_df</span>
<span id="cb33-161"><a href="#cb33-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-162"><a href="#cb33-162" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> pd.read_excel(<span class="st">'../Data/Stimmzettel 2011 Wahlbereich Bremen Vertrag.xlsx'</span>)</span>
<span id="cb33-163"><a href="#cb33-163" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011.iloc[<span class="dv">0</span>:]</span>
<span id="cb33-164"><a href="#cb33-164" aria-hidden="true" tabindex="-1"></a>new_headers <span class="op">=</span> df_2011.iloc[<span class="dv">0</span>]</span>
<span id="cb33-165"><a href="#cb33-165" aria-hidden="true" tabindex="-1"></a>df_2011.columns <span class="op">=</span> new_headers</span>
<span id="cb33-166"><a href="#cb33-166" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span>df_2011[<span class="dv">1</span>:]</span>
<span id="cb33-167"><a href="#cb33-167" aria-hidden="true" tabindex="-1"></a>df_2011.isnull()</span>
<span id="cb33-168"><a href="#cb33-168" aria-hidden="true" tabindex="-1"></a>df_2011.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-169"><a href="#cb33-169" aria-hidden="true" tabindex="-1"></a>Valid_count <span class="op">=</span> df_2011[df_2011[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb33-170"><a href="#cb33-170" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2011<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2011 Bremen data set of which </span><span class="sc">{</span>Valid_count<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb33-171"><a href="#cb33-171" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011[df_2011[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb33-172"><a href="#cb33-172" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011.drop(columns<span class="op">=</span><span class="st">"Bemerkungen"</span>)</span>
<span id="cb33-173"><a href="#cb33-173" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> df_2011.astype(<span class="bu">str</span>) </span>
<span id="cb33-174"><a href="#cb33-174" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2011.to_pickle("../../Data/prepared_date/Bremen_2011.pkl")</span></span>
<span id="cb33-175"><a href="#cb33-175" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2011</span></span>
<span id="cb33-176"><a href="#cb33-176" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb33-177"><a href="#cb33-177" aria-hidden="true" tabindex="-1"></a>bremen_2011_percent <span class="op">=</span> party_percentage_dist(df_2011, party_codes, year, district)</span>
<span id="cb33-178"><a href="#cb33-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-179"><a href="#cb33-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-180"><a href="#cb33-180" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Stimmzettel 2015 Wahlbereich Bremen Vertrag.xlsx"</span>)</span>
<span id="cb33-181"><a href="#cb33-181" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.iloc[<span class="dv">0</span>:]</span>
<span id="cb33-182"><a href="#cb33-182" aria-hidden="true" tabindex="-1"></a>new_headers <span class="op">=</span> df_2015.iloc[<span class="dv">0</span>]</span>
<span id="cb33-183"><a href="#cb33-183" aria-hidden="true" tabindex="-1"></a>df_2015.columns <span class="op">=</span> new_headers</span>
<span id="cb33-184"><a href="#cb33-184" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span>df_2015[<span class="dv">1</span>:]</span>
<span id="cb33-185"><a href="#cb33-185" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-186"><a href="#cb33-186" aria-hidden="true" tabindex="-1"></a>df_2015.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-187"><a href="#cb33-187" aria-hidden="true" tabindex="-1"></a>Valid_count_2015 <span class="op">=</span> df_2015[df_2015[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb33-188"><a href="#cb33-188" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2015<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2015 data set of which </span><span class="sc">{</span>Valid_count_2015<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb33-189"><a href="#cb33-189" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015[df_2015[<span class="st">'Bemerkungen'</span>] <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb33-190"><a href="#cb33-190" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.drop(columns<span class="op">=</span><span class="st">"Bemerkungen"</span>) </span>
<span id="cb33-191"><a href="#cb33-191" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> df_2015.astype(<span class="bu">str</span>)</span>
<span id="cb33-192"><a href="#cb33-192" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2015.to_pickle("../../Data/prepared_date/Bremen_2015.pkl")</span></span>
<span id="cb33-193"><a href="#cb33-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-194"><a href="#cb33-194" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2015</span></span>
<span id="cb33-195"><a href="#cb33-195" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb33-196"><a href="#cb33-196" aria-hidden="true" tabindex="-1"></a>bremen_2015_percent <span class="op">=</span> party_percentage_dist(df_2015, party_codes, year, district)</span>
<span id="cb33-197"><a href="#cb33-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-198"><a href="#cb33-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-199"><a href="#cb33-199" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Stimmzettel 2019 Wahlbereich Bremen Vertrag.xlsx"</span>)</span>
<span id="cb33-200"><a href="#cb33-200" aria-hidden="true" tabindex="-1"></a>df_2019.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-201"><a href="#cb33-201" aria-hidden="true" tabindex="-1"></a>Valid_count_2019 <span class="op">=</span> df_2019[df_2019[<span class="st">'Grund Ungültigkeit'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb33-202"><a href="#cb33-202" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2019<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2019 data set of which </span><span class="sc">{</span>Valid_count_2019<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb33-203"><a href="#cb33-203" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> df_2019[df_2019[<span class="st">'Grund Ungültigkeit'</span>] <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb33-204"><a href="#cb33-204" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> df_2019.drop(columns<span class="op">=</span><span class="st">"Grund Ungültigkeit"</span>) </span>
<span id="cb33-205"><a href="#cb33-205" aria-hidden="true" tabindex="-1"></a>df_2019.rename(columns<span class="op">=</span>{<span class="st">'Stimme1'</span>: <span class="st">'Stimme 1'</span>, <span class="st">'Stimme2'</span>:<span class="st">'Stimme 2'</span>, <span class="st">'Stimme3'</span>:<span class="st">'Stimme 3'</span>, <span class="st">'Stimme4'</span>:<span class="st">'Stimme 4'</span>, <span class="st">'Stimme5'</span>:<span class="st">'Stimme 5'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-206"><a href="#cb33-206" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> df_2019.astype(<span class="bu">int</span>).astype(<span class="bu">str</span>)</span>
<span id="cb33-207"><a href="#cb33-207" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2019.to_pickle("../../Data/prepared_date/Bremen_2019.pkl")</span></span>
<span id="cb33-208"><a href="#cb33-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-209"><a href="#cb33-209" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2019</span></span>
<span id="cb33-210"><a href="#cb33-210" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb33-211"><a href="#cb33-211" aria-hidden="true" tabindex="-1"></a>bremen_2019_percent <span class="op">=</span> party_percentage_dist(df_2019, party_codes, year, district)</span>
<span id="cb33-212"><a href="#cb33-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-213"><a href="#cb33-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-214"><a href="#cb33-214" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Stimmzettel 2023 Wahlbereich Bremen Vertrag.xlsx"</span>)</span>
<span id="cb33-215"><a href="#cb33-215" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.iloc[<span class="dv">0</span>:]</span>
<span id="cb33-216"><a href="#cb33-216" aria-hidden="true" tabindex="-1"></a>new_headers <span class="op">=</span> df_2023.iloc[<span class="dv">0</span>]</span>
<span id="cb33-217"><a href="#cb33-217" aria-hidden="true" tabindex="-1"></a>df_2023.columns <span class="op">=</span> new_headers</span>
<span id="cb33-218"><a href="#cb33-218" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span>df_2023[<span class="dv">1</span>:]</span>
<span id="cb33-219"><a href="#cb33-219" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-220"><a href="#cb33-220" aria-hidden="true" tabindex="-1"></a>Valid_count_2023 <span class="op">=</span> df_2023[df_2023[<span class="st">'Gültigkeit'</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb33-221"><a href="#cb33-221" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are a total of </span><span class="sc">{</span>df_2023<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> voters in the 2019 data set of which </span><span class="sc">{</span>Valid_count_2023<span class="sc">}</span><span class="ss"> successfully cast their votes"</span>)</span>
<span id="cb33-222"><a href="#cb33-222" aria-hidden="true" tabindex="-1"></a>df_2023.drop(df_2023[df_2023[<span class="st">'Gültigkeit'</span>] <span class="op">==</span> <span class="st">'Ungültig (per Beschluss)'</span>].index, inplace <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb33-223"><a href="#cb33-223" aria-hidden="true" tabindex="-1"></a>df_2023.drop(df_2023[df_2023[<span class="st">'Gültigkeit'</span>] <span class="op">==</span> <span class="st">'Ungültig'</span>].index, inplace <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb33-224"><a href="#cb33-224" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.drop(columns<span class="op">=</span><span class="st">"Gültigkeit"</span>)</span>
<span id="cb33-225"><a href="#cb33-225" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.drop(columns<span class="op">=</span><span class="st">"Bemerkung"</span>)</span>
<span id="cb33-226"><a href="#cb33-226" aria-hidden="true" tabindex="-1"></a>df_2023.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-227"><a href="#cb33-227" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> df_2023.astype(<span class="bu">str</span>)</span>
<span id="cb33-228"><a href="#cb33-228" aria-hidden="true" tabindex="-1"></a><span class="co">#df_2023.to_pickle("../../Data/prepared_date/Bremen_2023.pkl")</span></span>
<span id="cb33-229"><a href="#cb33-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-230"><a href="#cb33-230" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> <span class="dv">2023</span></span>
<span id="cb33-231"><a href="#cb33-231" aria-hidden="true" tabindex="-1"></a>district <span class="op">=</span> <span class="st">'Bremen'</span></span>
<span id="cb33-232"><a href="#cb33-232" aria-hidden="true" tabindex="-1"></a>bremen_2023_percent <span class="op">=</span> party_percentage_dist(df_2023, party_codes, year, district)</span>
<span id="cb33-233"><a href="#cb33-233" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-234"><a href="#cb33-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-235"><a href="#cb33-235" aria-hidden="true" tabindex="-1"></a><span class="fu">### Analysis of Party Vote Percentages Trends Over Four Elections</span></span>
<span id="cb33-236"><a href="#cb33-236" aria-hidden="true" tabindex="-1"></a>This chapter uses in-depth visuals to examine Bremen's vote trends during the last four election cycles. We can tell which political parties have seen a rise in support and which have seen a fall by looking at bar charts and line graphs that show the movements in party vote percentages. We can plainly see how the political scene is changing and how voter preferences are dynamically shifting thanks to these visual tools. This chapter seeks to give readers a thorough grasp of how various parties have fared over time, along with insights into the causes of these shifts and their consequences for upcoming elections.</span>
<span id="cb33-237"><a href="#cb33-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-238"><a href="#cb33-238" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-239"><a href="#cb33-239" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tabulate <span class="im">import</span> tabulate</span>
<span id="cb33-240"><a href="#cb33-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-241"><a href="#cb33-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-242"><a href="#cb33-242" aria-hidden="true" tabindex="-1"></a>top_n <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb33-243"><a href="#cb33-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-244"><a href="#cb33-244" aria-hidden="true" tabindex="-1"></a>table_2011_party <span class="op">=</span> tabulate(bremen_2011_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb33-245"><a href="#cb33-245" aria-hidden="true" tabindex="-1"></a>df_2011_sorted <span class="op">=</span> bremen_2011_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb33-246"><a href="#cb33-246" aria-hidden="true" tabindex="-1"></a>top_merged_df_2011 <span class="op">=</span> df_2011_sorted.head(top_n)</span>
<span id="cb33-247"><a href="#cb33-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-248"><a href="#cb33-248" aria-hidden="true" tabindex="-1"></a>table_2015_party <span class="op">=</span> tabulate(bremen_2015_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb33-249"><a href="#cb33-249" aria-hidden="true" tabindex="-1"></a>df_2015_sorted <span class="op">=</span> bremen_2015_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb33-250"><a href="#cb33-250" aria-hidden="true" tabindex="-1"></a>top_merged_df_2015 <span class="op">=</span> df_2015_sorted.head(top_n)</span>
<span id="cb33-251"><a href="#cb33-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-252"><a href="#cb33-252" aria-hidden="true" tabindex="-1"></a>table_2019_party <span class="op">=</span> tabulate(bremen_2019_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb33-253"><a href="#cb33-253" aria-hidden="true" tabindex="-1"></a>df_2019_sorted <span class="op">=</span> bremen_2019_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb33-254"><a href="#cb33-254" aria-hidden="true" tabindex="-1"></a>top_merged_df_2019 <span class="op">=</span> df_2019_sorted.head(top_n)</span>
<span id="cb33-255"><a href="#cb33-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-256"><a href="#cb33-256" aria-hidden="true" tabindex="-1"></a>table_2023_party <span class="op">=</span> tabulate(bremen_2023_percent, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>)</span>
<span id="cb33-257"><a href="#cb33-257" aria-hidden="true" tabindex="-1"></a>df_2023_sorted <span class="op">=</span> bremen_2023_percent.sort_values(by<span class="op">=</span><span class="st">'percentage %'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb33-258"><a href="#cb33-258" aria-hidden="true" tabindex="-1"></a>top_merged_df_2023 <span class="op">=</span>  df_2023_sorted.head(top_n)</span>
<span id="cb33-259"><a href="#cb33-259" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_and_print_tables(tables, titles):</span>
<span id="cb33-260"><a href="#cb33-260" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> title, table <span class="kw">in</span> <span class="bu">zip</span>(titles, tables):</span>
<span id="cb33-261"><a href="#cb33-261" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>title<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb33-262"><a href="#cb33-262" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(table)</span>
<span id="cb33-263"><a href="#cb33-263" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">80</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb33-264"><a href="#cb33-264" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb33-265"><a href="#cb33-265" aria-hidden="true" tabindex="-1"></a><span class="co"># Prepare the tables</span></span>
<span id="cb33-266"><a href="#cb33-266" aria-hidden="true" tabindex="-1"></a><span class="co">table_2011_party = tabulate(top_merged_df_2011, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb33-267"><a href="#cb33-267" aria-hidden="true" tabindex="-1"></a><span class="co">table_2015_party = tabulate(top_merged_df_2015, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb33-268"><a href="#cb33-268" aria-hidden="true" tabindex="-1"></a><span class="co">table_2019_party = tabulate(top_merged_df_2019, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb33-269"><a href="#cb33-269" aria-hidden="true" tabindex="-1"></a><span class="co">table_2023_party = tabulate(top_merged_df_2023, headers='keys', tablefmt='fancy_grid')</span></span>
<span id="cb33-270"><a href="#cb33-270" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb33-271"><a href="#cb33-271" aria-hidden="true" tabindex="-1"></a>titles_side_by_side <span class="op">=</span> [<span class="st">"Bremen 2011"</span>, <span class="st">"Bremen 2015"</span>]</span>
<span id="cb33-272"><a href="#cb33-272" aria-hidden="true" tabindex="-1"></a>titles_beneath <span class="op">=</span> [<span class="st">"Bremen 2019"</span>, <span class="st">"Bremen 2023"</span>]</span>
<span id="cb33-273"><a href="#cb33-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-274"><a href="#cb33-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-275"><a href="#cb33-275" aria-hidden="true" tabindex="-1"></a><span class="co"># Titles for the tables</span></span>
<span id="cb33-276"><a href="#cb33-276" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Bremen 2011"</span>, <span class="st">"Bremen 2015"</span>, <span class="st">"Bremen 2019"</span>, <span class="st">"Bremen 2023"</span>]</span>
<span id="cb33-277"><a href="#cb33-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-278"><a href="#cb33-278" aria-hidden="true" tabindex="-1"></a><span class="co"># Print each table on its own line</span></span>
<span id="cb33-279"><a href="#cb33-279" aria-hidden="true" tabindex="-1"></a>format_and_print_tables([table_2011_party, table_2015_party, table_2019_party, table_2023_party], titles)</span>
<span id="cb33-280"><a href="#cb33-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-281"><a href="#cb33-281" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-282"><a href="#cb33-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-283"><a href="#cb33-283" aria-hidden="true" tabindex="-1"></a>The bar charts plotted below illustrate the percentage of votes received by each political party in Bremen over the last four electoral cycles. These visualizations provide a clear depiction of the shifting political landscape in the region. The Social Democratic Party (SPD) has traditionally maintained a strong presence, although its vote share has fluctuated. The Christian Democratic Union (CDU) has similarly experienced variations in its support base, reflecting changing voter sentiments. The Green Party (Die Grünen) has shown a steady increase in vote percentages, highlighting growing environmental and social awareness among the electorate. Conversely, the Left Party (Die Linke) and the Free Democratic Party (FDP) have witnessed more variable performance, indicative of their targeted, sometimes niche appeal. Notably, the rise of the Alternative for Germany (AfD), a far-right party, underscores a significant shift in a portion of the voter base towards more nationalist and populist ideologies. These bar charts not only showcase the ebb and flow of party support but also offer insights into broader electoral trends and the evolving political priorities of Bremen's voters. This analysis forms a crucial foundation for understanding the dynamics of voter behavior and the strategic adaptations of political parties over time.</span>
<span id="cb33-284"><a href="#cb33-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-285"><a href="#cb33-285" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo = FALSE}</span></span>
<span id="cb33-286"><a href="#cb33-286" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb33-287"><a href="#cb33-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-288"><a href="#cb33-288" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">16</span>))</span>
<span id="cb33-289"><a href="#cb33-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-290"><a href="#cb33-290" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_color(row):</span>
<span id="cb33-291"><a href="#cb33-291" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">'grey'</span> <span class="cf">if</span> pd.isna(row[<span class="st">'Colour'</span>]) <span class="cf">else</span> row[<span class="st">'Colour'</span>]</span>
<span id="cb33-292"><a href="#cb33-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-293"><a href="#cb33-293" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df, ax, title <span class="kw">in</span> <span class="bu">zip</span>([top_merged_df_2011, top_merged_df_2015, top_merged_df_2019, top_merged_df_2023],</span>
<span id="cb33-294"><a href="#cb33-294" aria-hidden="true" tabindex="-1"></a>                         axs.flatten(), [<span class="st">'Bremen 2011'</span>, <span class="st">'Bremen 2015'</span>, <span class="st">'Bremen 2019'</span>, <span class="st">'Bremen 2023'</span>]):</span>
<span id="cb33-295"><a href="#cb33-295" aria-hidden="true" tabindex="-1"></a>    df.plot.bar(x<span class="op">=</span><span class="st">'Kurzform'</span>, y<span class="op">=</span><span class="st">'percentage %'</span>, rot<span class="op">=</span><span class="dv">0</span>, ax<span class="op">=</span>ax, color<span class="op">=</span>df.<span class="bu">apply</span>(get_color, axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb33-296"><a href="#cb33-296" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title)</span>
<span id="cb33-297"><a href="#cb33-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-298"><a href="#cb33-298" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb33-299"><a href="#cb33-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-300"><a href="#cb33-300" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb33-301"><a href="#cb33-301" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-302"><a href="#cb33-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-303"><a href="#cb33-303" aria-hidden="true" tabindex="-1"></a>The line graph presented below highlights the changing vote percentages for each political party in Bremen over the past four electoral cycles, offering a dynamic view of party growth and decline. The graph traces the trajectory of each party's performance, revealing significant trends and shifts in voter allegiance.</span>
<span id="cb33-304"><a href="#cb33-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-305"><a href="#cb33-305" aria-hidden="true" tabindex="-1"></a>The Social Democratic Party (SPD) has shown a general decline over the years. In 2011, the SPD garnered almost 40% of the votes, but this support has steadily decreased, reaching a low of about 25% in 2015. This downward trend indicates a diminishing traditional support base for the SPD in Bremen.</span>
<span id="cb33-306"><a href="#cb33-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-307"><a href="#cb33-307" aria-hidden="true" tabindex="-1"></a>Conversely, the Christian Democratic Union (CDU) is on an upward trajectory. Starting with approximately 20% of the votes in 2011, the CDU has seen a steady increase over the years, reaching around 27% in the most recent election. This growth suggests a strengthening of the CDU's appeal among Bremen's electorate.</span>
<span id="cb33-308"><a href="#cb33-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-309"><a href="#cb33-309" aria-hidden="true" tabindex="-1"></a>The Green Party (Die Grünen) has experienced a steady decrease in its vote share, declining from about 23% in 2011 to 17% in 2023. This trend reflects a shift in voter priorities or a possible realignment of the environmental and progressive agenda within the broader political spectrum.</span>
<span id="cb33-310"><a href="#cb33-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-311"><a href="#cb33-311" aria-hidden="true" tabindex="-1"></a>The Left Party (Die Linke) is on a steady increase, with its vote share rising from 6% in 2011 to about 12% in 2023. This upward trend indicates a growing appeal for the Left Party's platform and policies among voters in Bremen.</span>
<span id="cb33-312"><a href="#cb33-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-313"><a href="#cb33-313" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo = FALSE}</span></span>
<span id="cb33-314"><a href="#cb33-314" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> bremen_2011_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2011'</span>})</span>
<span id="cb33-315"><a href="#cb33-315" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> bremen_2015_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2015'</span>})</span>
<span id="cb33-316"><a href="#cb33-316" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> bremen_2019_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2019'</span>})</span>
<span id="cb33-317"><a href="#cb33-317" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> bremen_2023_percent[[<span class="st">'Kurzform'</span>, <span class="st">'percentage %'</span>, <span class="st">'Colour'</span>]].rename(columns<span class="op">=</span>{<span class="st">'percentage %'</span>: <span class="st">'2023'</span>})</span>
<span id="cb33-318"><a href="#cb33-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-319"><a href="#cb33-319" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> df_2011.merge(df_2015, on<span class="op">=</span>[<span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>], how<span class="op">=</span><span class="st">'outer'</span>)</span>
<span id="cb33-320"><a href="#cb33-320" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.merge(df_2019, on<span class="op">=</span>[<span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>], how<span class="op">=</span><span class="st">'outer'</span>)</span>
<span id="cb33-321"><a href="#cb33-321" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.merge(df_2023, on<span class="op">=</span>[<span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>], how<span class="op">=</span><span class="st">'outer'</span>)</span>
<span id="cb33-322"><a href="#cb33-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-323"><a href="#cb33-323" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.fillna({<span class="st">'2011'</span>: <span class="dv">0</span>, <span class="st">'2015'</span>: <span class="dv">0</span>, <span class="st">'2019'</span>: <span class="dv">0</span>, <span class="st">'2023'</span>: <span class="dv">0</span>})</span>
<span id="cb33-324"><a href="#cb33-324" aria-hidden="true" tabindex="-1"></a>merged_df[<span class="st">'Colour'</span>] <span class="op">=</span> merged_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>)</span>
<span id="cb33-325"><a href="#cb33-325" aria-hidden="true" tabindex="-1"></a>others_df <span class="op">=</span> merged_df[merged_df[<span class="st">'Colour'</span>] <span class="op">==</span> <span class="st">'grey'</span>]</span>
<span id="cb33-326"><a href="#cb33-326" aria-hidden="true" tabindex="-1"></a>others_sums <span class="op">=</span> others_df[[<span class="st">'2011'</span>, <span class="st">'2015'</span>, <span class="st">'2019'</span>, <span class="st">'2023'</span>]].<span class="bu">sum</span>()</span>
<span id="cb33-327"><a href="#cb33-327" aria-hidden="true" tabindex="-1"></a>others_sums[<span class="st">'Kurzform'</span>] <span class="op">=</span> <span class="st">'Others'</span></span>
<span id="cb33-328"><a href="#cb33-328" aria-hidden="true" tabindex="-1"></a>others_sums[<span class="st">'Colour'</span>] <span class="op">=</span> <span class="st">'grey'</span></span>
<span id="cb33-329"><a href="#cb33-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-330"><a href="#cb33-330" aria-hidden="true" tabindex="-1"></a>filtered_df <span class="op">=</span> merged_df[merged_df[<span class="st">'Colour'</span>] <span class="op">!=</span> <span class="st">'grey'</span>]</span>
<span id="cb33-331"><a href="#cb33-331" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> pd.concat([filtered_df, pd.DataFrame([others_sums])], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-332"><a href="#cb33-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-333"><a href="#cb33-333" aria-hidden="true" tabindex="-1"></a>final_df.set_index(<span class="st">'Kurzform'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-334"><a href="#cb33-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-335"><a href="#cb33-335" aria-hidden="true" tabindex="-1"></a>transposed_df <span class="op">=</span> final_df[[<span class="st">'2011'</span>, <span class="st">'2015'</span>, <span class="st">'2019'</span>, <span class="st">'2023'</span>]].T</span>
<span id="cb33-336"><a href="#cb33-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-337"><a href="#cb33-337" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb33-338"><a href="#cb33-338" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> party <span class="kw">in</span> transposed_df.columns:</span>
<span id="cb33-339"><a href="#cb33-339" aria-hidden="true" tabindex="-1"></a>    plt.plot(transposed_df.index, transposed_df[party], marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span>party, color<span class="op">=</span>final_df.loc[party, <span class="st">'Colour'</span>])</span>
<span id="cb33-340"><a href="#cb33-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-341"><a href="#cb33-341" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Votes of Each Party in Bremen Elections (2011-2023)'</span>)</span>
<span id="cb33-342"><a href="#cb33-342" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Year'</span>)</span>
<span id="cb33-343"><a href="#cb33-343" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Vote Percentage'</span>)</span>
<span id="cb33-344"><a href="#cb33-344" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">'Party'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">1.05</span>, <span class="dv">1</span>), loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb33-345"><a href="#cb33-345" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb33-346"><a href="#cb33-346" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb33-347"><a href="#cb33-347" aria-hidden="true" tabindex="-1"></a>plt.show()  </span>
<span id="cb33-348"><a href="#cb33-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-349"><a href="#cb33-349" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-350"><a href="#cb33-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-351"><a href="#cb33-351" aria-hidden="true" tabindex="-1"></a>Additionally, the political landscape has been enriched by the emergence of new parties such as Volt. Although still gaining traction, Volt's presence in the political arena signifies the evolving nature of voter preferences and the increasing diversification of political representation.</span>
<span id="cb33-352"><a href="#cb33-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-353"><a href="#cb33-353" aria-hidden="true" tabindex="-1"></a>Overall, the line graph effectively captures the dynamic and evolving nature of political party support in Bremen. It provides valuable insights into how parties have adapted to changing voter priorities and the broader socio-political environment. This analysis is crucial for understanding the strategic responses of political parties and predicting future electoral outcomes.</span>
<span id="cb33-354"><a href="#cb33-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-355"><a href="#cb33-355" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo =FALSE}</span></span>
<span id="cb33-356"><a href="#cb33-356" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb33-357"><a href="#cb33-357" aria-hidden="true" tabindex="-1"></a><span class="co"># read the party codes</span></span>
<span id="cb33-358"><a href="#cb33-358" aria-hidden="true" tabindex="-1"></a><span class="co">#-----------------------</span></span>
<span id="cb33-359"><a href="#cb33-359" aria-hidden="true" tabindex="-1"></a>party_codes <span class="op">=</span> pd.read_excel(<span class="st">"../Data/Parteien-Codes.xlsx"</span>)</span>
<span id="cb33-360"><a href="#cb33-360" aria-hidden="true" tabindex="-1"></a>party_codes_2011 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2011</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb33-361"><a href="#cb33-361" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb33-362"><a href="#cb33-362" aria-hidden="true" tabindex="-1"></a>party_codes_2015 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2015</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb33-363"><a href="#cb33-363" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>,  <span class="st">'Colour'</span>]]</span>
<span id="cb33-364"><a href="#cb33-364" aria-hidden="true" tabindex="-1"></a>party_codes_2019 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2019</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb33-365"><a href="#cb33-365" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>,  <span class="st">'Colour'</span>]]</span>
<span id="cb33-366"><a href="#cb33-366" aria-hidden="true" tabindex="-1"></a>party_codes_2023 <span class="op">=</span> party_codes[(party_codes[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2023</span>) <span class="op">&amp;</span> (party_codes[<span class="st">'district'</span>] <span class="op">==</span> </span>
<span id="cb33-367"><a href="#cb33-367" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Bremen'</span>)][[<span class="st">'party_id'</span>, <span class="st">'Kurzform'</span>,  <span class="st">'Colour'</span>]]</span>
<span id="cb33-368"><a href="#cb33-368" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------</span></span>
<span id="cb33-369"><a href="#cb33-369" aria-hidden="true" tabindex="-1"></a><span class="co"># Load datasets and get the numbers of voters for each party</span></span>
<span id="cb33-370"><a href="#cb33-370" aria-hidden="true" tabindex="-1"></a><span class="co">#------</span></span>
<span id="cb33-371"><a href="#cb33-371" aria-hidden="true" tabindex="-1"></a>df_2011 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2011.pkl"</span>)</span>
<span id="cb33-372"><a href="#cb33-372" aria-hidden="true" tabindex="-1"></a>df_2015 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2015.pkl"</span>)</span>
<span id="cb33-373"><a href="#cb33-373" aria-hidden="true" tabindex="-1"></a>df_2019 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2019.pkl"</span>)</span>
<span id="cb33-374"><a href="#cb33-374" aria-hidden="true" tabindex="-1"></a>df_2023 <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/Bremen_2023.pkl"</span>)</span>
<span id="cb33-375"><a href="#cb33-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-376"><a href="#cb33-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-377"><a href="#cb33-377" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_hundredth(df):</span>
<span id="cb33-378"><a href="#cb33-378" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="bu">int</span>)</span>
<span id="cb33-379"><a href="#cb33-379" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-380"><a href="#cb33-380" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="kw">lambda</span> x: (x <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb33-381"><a href="#cb33-381" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-382"><a href="#cb33-382" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb33-383"><a href="#cb33-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-384"><a href="#cb33-384" aria-hidden="true" tabindex="-1"></a>df_bre_2011 <span class="op">=</span> convert_to_hundredth(df_2011)</span>
<span id="cb33-385"><a href="#cb33-385" aria-hidden="true" tabindex="-1"></a>df_bre_2015 <span class="op">=</span> convert_to_hundredth(df_2015)</span>
<span id="cb33-386"><a href="#cb33-386" aria-hidden="true" tabindex="-1"></a>df_bre_2019 <span class="op">=</span> convert_to_hundredth(df_2019)</span>
<span id="cb33-387"><a href="#cb33-387" aria-hidden="true" tabindex="-1"></a>df_bre_2023 <span class="op">=</span> convert_to_hundredth(df_2023)</span>
<span id="cb33-388"><a href="#cb33-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-389"><a href="#cb33-389" aria-hidden="true" tabindex="-1"></a><span class="co">############ -----------------------------</span></span>
<span id="cb33-390"><a href="#cb33-390" aria-hidden="true" tabindex="-1"></a><span class="co">#Convert the party codes to names</span></span>
<span id="cb33-391"><a href="#cb33-391" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------</span></span>
<span id="cb33-392"><a href="#cb33-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-393"><a href="#cb33-393" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> replace_codes_with_names(df_data, df_codes):</span>
<span id="cb33-394"><a href="#cb33-394" aria-hidden="true" tabindex="-1"></a>    merged_columns <span class="op">=</span> []</span>
<span id="cb33-395"><a href="#cb33-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-396"><a href="#cb33-396" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> code_column <span class="kw">in</span> [<span class="st">'Stimme 1'</span>, <span class="st">'Stimme 2'</span>, <span class="st">'Stimme 3'</span>, <span class="st">'Stimme 4'</span>, <span class="st">'Stimme 5'</span>]:</span>
<span id="cb33-397"><a href="#cb33-397" aria-hidden="true" tabindex="-1"></a>        merged_df <span class="op">=</span> pd.merge(df_data, df_codes, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span>code_column, right_on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb33-398"><a href="#cb33-398" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-399"><a href="#cb33-399" aria-hidden="true" tabindex="-1"></a>        merged_df.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> merged_df.columns <span class="cf">if</span> col <span class="op">!=</span> <span class="st">'Kurzform'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-400"><a href="#cb33-400" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-401"><a href="#cb33-401" aria-hidden="true" tabindex="-1"></a>        merged_df.rename(columns<span class="op">=</span>{<span class="st">'Kurzform'</span>: code_column}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-402"><a href="#cb33-402" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-403"><a href="#cb33-403" aria-hidden="true" tabindex="-1"></a>        merged_columns.append(merged_df)</span>
<span id="cb33-404"><a href="#cb33-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-405"><a href="#cb33-405" aria-hidden="true" tabindex="-1"></a>    final_df <span class="op">=</span> pd.concat(merged_columns, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb33-406"><a href="#cb33-406" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-407"><a href="#cb33-407" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_df</span>
<span id="cb33-408"><a href="#cb33-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-409"><a href="#cb33-409" aria-hidden="true" tabindex="-1"></a>df_bre_2011_prty <span class="op">=</span> replace_codes_with_names(df_bre_2011, party_codes_2011)</span>
<span id="cb33-410"><a href="#cb33-410" aria-hidden="true" tabindex="-1"></a>df_bre_2015_prty <span class="op">=</span> replace_codes_with_names(df_bre_2015, party_codes_2015)</span>
<span id="cb33-411"><a href="#cb33-411" aria-hidden="true" tabindex="-1"></a>df_bre_2019_prty <span class="op">=</span> replace_codes_with_names(df_bre_2019, party_codes_2019)</span>
<span id="cb33-412"><a href="#cb33-412" aria-hidden="true" tabindex="-1"></a>df_bre_2023_prty <span class="op">=</span> replace_codes_with_names(df_bre_2023, party_codes_2023)</span>
<span id="cb33-413"><a href="#cb33-413" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------------</span></span>
<span id="cb33-414"><a href="#cb33-414" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to get total voters for each pary</span></span>
<span id="cb33-415"><a href="#cb33-415" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------</span></span>
<span id="cb33-416"><a href="#cb33-416" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_total_voters(df):</span>
<span id="cb33-417"><a href="#cb33-417" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.dropna()</span>
<span id="cb33-418"><a href="#cb33-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-419"><a href="#cb33-419" aria-hidden="true" tabindex="-1"></a>    unique_counts <span class="op">=</span> {}</span>
<span id="cb33-420"><a href="#cb33-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-421"><a href="#cb33-421" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb33-422"><a href="#cb33-422" aria-hidden="true" tabindex="-1"></a>        unique_values_in_row <span class="op">=</span> <span class="bu">set</span>(row)</span>
<span id="cb33-423"><a href="#cb33-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-424"><a href="#cb33-424" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> value <span class="kw">in</span> unique_values_in_row:</span>
<span id="cb33-425"><a href="#cb33-425" aria-hidden="true" tabindex="-1"></a>            unique_counts[value] <span class="op">=</span> unique_counts.get(value, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb33-426"><a href="#cb33-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-427"><a href="#cb33-427" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the dictionary to a DataFrame</span></span>
<span id="cb33-428"><a href="#cb33-428" aria-hidden="true" tabindex="-1"></a>    unique_counts_df <span class="op">=</span> pd.DataFrame(<span class="bu">list</span>(unique_counts.items()), columns<span class="op">=</span>[<span class="st">'Party_id'</span>, <span class="st">'Total_voters'</span>])</span>
<span id="cb33-429"><a href="#cb33-429" aria-hidden="true" tabindex="-1"></a>    <span class="co">#df_party = df_party_pairs.merge(df_total_voters, how='left', left_on='Party_Code_A', right_on='Party_id')</span></span>
<span id="cb33-430"><a href="#cb33-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-431"><a href="#cb33-431" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> unique_counts_df</span>
<span id="cb33-432"><a href="#cb33-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-433"><a href="#cb33-433" aria-hidden="true" tabindex="-1"></a>df_2011_total_voters <span class="op">=</span> count_total_voters(df_bre_2011_prty)</span>
<span id="cb33-434"><a href="#cb33-434" aria-hidden="true" tabindex="-1"></a>df_2015_total_voters <span class="op">=</span> count_total_voters(df_bre_2015_prty)</span>
<span id="cb33-435"><a href="#cb33-435" aria-hidden="true" tabindex="-1"></a>df_2019_total_voters <span class="op">=</span> count_total_voters(df_bre_2019_prty)</span>
<span id="cb33-436"><a href="#cb33-436" aria-hidden="true" tabindex="-1"></a>df_2023_total_voters <span class="op">=</span> count_total_voters(df_bre_2023_prty)</span>
<span id="cb33-437"><a href="#cb33-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-438"><a href="#cb33-438" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-439"><a href="#cb33-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-440"><a href="#cb33-440" aria-hidden="true" tabindex="-1"></a>**Co-voter Percentage Matrix**</span>
<span id="cb33-441"><a href="#cb33-441" aria-hidden="true" tabindex="-1"></a>In the first approach, we constructed a matrix based on the percentages of co-voters for each pair of political parties. Here, co-voters are defined as voters who voted for both parties in question. For each pair of parties, we calculated the average of co-voters on both direction, ie avegrage of percentage of Party A voters that voted for Party B and vice viser. This method emphasizes the overlap in voter bases between different parties, providing insight into potential alliances or ideological similarities.</span>
<span id="cb33-442"><a href="#cb33-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-443"><a href="#cb33-443" aria-hidden="true" tabindex="-1"></a>For example, if Party A and Party B share a significant percentage of their voters, this will result in a higher value in the co-voter percentage matrix. Likewise, parties with minimal overlap in their voter bases will show lower values. This matrix, therefore, serves as a measure of voter commonality and helps identify clusters of parties with shared electorates and share common values.</span>
<span id="cb33-444"><a href="#cb33-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-445"><a href="#cb33-445" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-446"><a href="#cb33-446" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb33-447"><a href="#cb33-447" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb33-448"><a href="#cb33-448" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------------</span></span>
<span id="cb33-449"><a href="#cb33-449" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate Uniqure pairs of parties that voters voted for</span></span>
<span id="cb33-450"><a href="#cb33-450" aria-hidden="true" tabindex="-1"></a><span class="co"># ---------------------------</span></span>
<span id="cb33-451"><a href="#cb33-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-452"><a href="#cb33-452" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unique_pairs_with_count(df):</span>
<span id="cb33-453"><a href="#cb33-453" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="bu">int</span>)</span>
<span id="cb33-454"><a href="#cb33-454" aria-hidden="true" tabindex="-1"></a>    pair_counter <span class="op">=</span> Counter()</span>
<span id="cb33-455"><a href="#cb33-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-456"><a href="#cb33-456" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb33-457"><a href="#cb33-457" aria-hidden="true" tabindex="-1"></a>        row_values <span class="op">=</span> [(x <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span> <span class="dv">100</span> <span class="cf">for</span> x <span class="kw">in</span> row <span class="cf">if</span> x<span class="op">!=</span> <span class="dv">0</span>]</span>
<span id="cb33-458"><a href="#cb33-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-459"><a href="#cb33-459" aria-hidden="true" tabindex="-1"></a>        unique_pairs <span class="op">=</span> <span class="bu">set</span>(combinations(row_values, <span class="dv">2</span>))</span>
<span id="cb33-460"><a href="#cb33-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-461"><a href="#cb33-461" aria-hidden="true" tabindex="-1"></a>        pair_counter.update(unique_pairs)</span>
<span id="cb33-462"><a href="#cb33-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-463"><a href="#cb33-463" aria-hidden="true" tabindex="-1"></a>    pair_counts_df <span class="op">=</span> pd.DataFrame(pair_counter.items(), columns<span class="op">=</span>[<span class="st">'Pair'</span>, <span class="st">'Count'</span>])</span>
<span id="cb33-464"><a href="#cb33-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-465"><a href="#cb33-465" aria-hidden="true" tabindex="-1"></a>    pair_counts_df[[<span class="st">'Party_Code_A'</span>, <span class="st">'Party_Code_B'</span>]] <span class="op">=</span> pd.DataFrame(pair_counts_df[<span class="st">'Pair'</span>].tolist())</span>
<span id="cb33-466"><a href="#cb33-466" aria-hidden="true" tabindex="-1"></a>    pair_counts_df <span class="op">=</span> pair_counts_df[[<span class="st">'Party_Code_A'</span>, <span class="st">'Party_Code_B'</span>, <span class="st">'Count'</span>]]</span>
<span id="cb33-467"><a href="#cb33-467" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-468"><a href="#cb33-468" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pair_counts_df</span>
<span id="cb33-469"><a href="#cb33-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-470"><a href="#cb33-470" aria-hidden="true" tabindex="-1"></a>df_2011_pair <span class="op">=</span> unique_pairs_with_count(df_2011)</span>
<span id="cb33-471"><a href="#cb33-471" aria-hidden="true" tabindex="-1"></a>df_2015_pair <span class="op">=</span> unique_pairs_with_count(df_2015)</span>
<span id="cb33-472"><a href="#cb33-472" aria-hidden="true" tabindex="-1"></a>df_2019_pair <span class="op">=</span> unique_pairs_with_count(df_2019)</span>
<span id="cb33-473"><a href="#cb33-473" aria-hidden="true" tabindex="-1"></a>df_2023_pair <span class="op">=</span> unique_pairs_with_count(df_2023)</span>
<span id="cb33-474"><a href="#cb33-474" aria-hidden="true" tabindex="-1"></a>df_2011_pair.head(<span class="dv">10</span>)</span>
<span id="cb33-475"><a href="#cb33-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-476"><a href="#cb33-476" aria-hidden="true" tabindex="-1"></a><span class="co">#------------------------</span></span>
<span id="cb33-477"><a href="#cb33-477" aria-hidden="true" tabindex="-1"></a><span class="co"># Replace party codes with party names in the covoter dataframe </span></span>
<span id="cb33-478"><a href="#cb33-478" aria-hidden="true" tabindex="-1"></a><span class="co">#-------------------------</span></span>
<span id="cb33-479"><a href="#cb33-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-480"><a href="#cb33-480" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_and_clean(df, party_codes):</span>
<span id="cb33-481"><a href="#cb33-481" aria-hidden="true" tabindex="-1"></a>    <span class="co">#df_merged= df.merge(party_votes, how='left', left_on ='Party_Code_A', right_on= ['Party_id'])</span></span>
<span id="cb33-482"><a href="#cb33-482" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Merge with party codes for party A</span></span>
<span id="cb33-483"><a href="#cb33-483" aria-hidden="true" tabindex="-1"></a>    df_merged <span class="op">=</span> df.merge(party_codes, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'Party_Code_A'</span>, right_on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb33-484"><a href="#cb33-484" aria-hidden="true" tabindex="-1"></a>    df_merged.drop(columns<span class="op">=</span>[<span class="st">'party_id'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-485"><a href="#cb33-485" aria-hidden="true" tabindex="-1"></a>    df_merged.rename(columns<span class="op">=</span>{<span class="st">'Kurzform'</span>: <span class="st">'party_A'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-486"><a href="#cb33-486" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-487"><a href="#cb33-487" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Merge with party codes for party B</span></span>
<span id="cb33-488"><a href="#cb33-488" aria-hidden="true" tabindex="-1"></a>    df_merged <span class="op">=</span> df_merged.merge(party_codes, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'Party_Code_B'</span>, right_on<span class="op">=</span><span class="st">'party_id'</span>)</span>
<span id="cb33-489"><a href="#cb33-489" aria-hidden="true" tabindex="-1"></a>    df_merged.drop(columns<span class="op">=</span>[<span class="st">'party_id'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-490"><a href="#cb33-490" aria-hidden="true" tabindex="-1"></a>    df_merged.rename(columns<span class="op">=</span>{<span class="st">'Kurzform'</span>: <span class="st">'party_B'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-491"><a href="#cb33-491" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-492"><a href="#cb33-492" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_merged</span>
<span id="cb33-493"><a href="#cb33-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-494"><a href="#cb33-494" aria-hidden="true" tabindex="-1"></a>df_2011_party_pairs <span class="op">=</span> merge_and_clean(df_2011_pair, party_codes_2011)</span>
<span id="cb33-495"><a href="#cb33-495" aria-hidden="true" tabindex="-1"></a>df_2015_party_pairs <span class="op">=</span> merge_and_clean(df_2015_pair, party_codes_2015)</span>
<span id="cb33-496"><a href="#cb33-496" aria-hidden="true" tabindex="-1"></a>df_2019_party_pairs <span class="op">=</span> merge_and_clean(df_2019_pair, party_codes_2019)</span>
<span id="cb33-497"><a href="#cb33-497" aria-hidden="true" tabindex="-1"></a>df_2023_party_pairs <span class="op">=</span> merge_and_clean(df_2023_pair, party_codes_2023)</span>
<span id="cb33-498"><a href="#cb33-498" aria-hidden="true" tabindex="-1"></a>df_2011_party_pairs.head(<span class="dv">10</span>)</span>
<span id="cb33-499"><a href="#cb33-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-500"><a href="#cb33-500" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------------------</span></span>
<span id="cb33-501"><a href="#cb33-501" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the avaerage percentage of co voters to compute the matrix</span></span>
<span id="cb33-502"><a href="#cb33-502" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------------------</span></span>
<span id="cb33-503"><a href="#cb33-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-504"><a href="#cb33-504" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_party_voting_percentages(df_party_pairs, df_total_voters):</span>
<span id="cb33-505"><a href="#cb33-505" aria-hidden="true" tabindex="-1"></a>    df_party <span class="op">=</span> df_party_pairs.merge(df_total_voters, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'party_A'</span>, right_on<span class="op">=</span><span class="st">'Party_id'</span>)</span>
<span id="cb33-506"><a href="#cb33-506" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-507"><a href="#cb33-507" aria-hidden="true" tabindex="-1"></a>    df_party[<span class="st">'Percentage_A_voted_B'</span>] <span class="op">=</span> (df_party[<span class="st">'Count'</span>] <span class="op">/</span> df_party[<span class="st">'Total_voters'</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb33-508"><a href="#cb33-508" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-509"><a href="#cb33-509" aria-hidden="true" tabindex="-1"></a>    df_party.drop(columns<span class="op">=</span>[<span class="st">'Total_voters'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-510"><a href="#cb33-510" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-511"><a href="#cb33-511" aria-hidden="true" tabindex="-1"></a>    df_party <span class="op">=</span> df_party.merge(df_total_voters, how<span class="op">=</span><span class="st">'left'</span>, left_on<span class="op">=</span><span class="st">'party_B'</span>, right_on<span class="op">=</span><span class="st">'Party_id'</span>, suffixes<span class="op">=</span>(<span class="st">'_A'</span>, <span class="st">'_B'</span>))</span>
<span id="cb33-512"><a href="#cb33-512" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-513"><a href="#cb33-513" aria-hidden="true" tabindex="-1"></a>    df_party[<span class="st">'Percentage_B_voted_A'</span>] <span class="op">=</span> (df_party[<span class="st">'Count'</span>] <span class="op">/</span> df_party[<span class="st">'Total_voters'</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb33-514"><a href="#cb33-514" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-515"><a href="#cb33-515" aria-hidden="true" tabindex="-1"></a>    df_party.drop(columns<span class="op">=</span>[<span class="st">'Total_voters'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-516"><a href="#cb33-516" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-517"><a href="#cb33-517" aria-hidden="true" tabindex="-1"></a>    df_party_result <span class="op">=</span> df_party[[<span class="st">'party_A'</span>, <span class="st">'party_B'</span>, <span class="st">'Count'</span>, <span class="st">'Percentage_A_voted_B'</span>, <span class="st">'Percentage_B_voted_A'</span>]]</span>
<span id="cb33-518"><a href="#cb33-518" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-519"><a href="#cb33-519" aria-hidden="true" tabindex="-1"></a>    df_party_result[<span class="st">'Average_percentage'</span>] <span class="op">=</span> ((df_party_result[<span class="st">'Percentage_A_voted_B'</span>] <span class="op">+</span> df_party_result[<span class="st">'Percentage_B_voted_A'</span>]) <span class="op">/</span> <span class="dv">200</span>).<span class="bu">round</span>(<span class="dv">1</span>)</span>
<span id="cb33-520"><a href="#cb33-520" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-521"><a href="#cb33-521" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_party_result</span>
<span id="cb33-522"><a href="#cb33-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-523"><a href="#cb33-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-524"><a href="#cb33-524" aria-hidden="true" tabindex="-1"></a>df_2011_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2011_party_pairs,df_2011_total_voters)</span>
<span id="cb33-525"><a href="#cb33-525" aria-hidden="true" tabindex="-1"></a>df_2015_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2015_party_pairs,df_2015_total_voters)</span>
<span id="cb33-526"><a href="#cb33-526" aria-hidden="true" tabindex="-1"></a>df_2019_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2019_party_pairs,df_2019_total_voters)</span>
<span id="cb33-527"><a href="#cb33-527" aria-hidden="true" tabindex="-1"></a>df_2023_party_percentages <span class="op">=</span> compute_party_voting_percentages(df_2023_party_pairs,df_2023_total_voters)</span>
<span id="cb33-528"><a href="#cb33-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-529"><a href="#cb33-529" aria-hidden="true" tabindex="-1"></a>df_2011_party_percentages.head(<span class="dv">10</span>)</span>
<span id="cb33-530"><a href="#cb33-530" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-531"><a href="#cb33-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-532"><a href="#cb33-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-533"><a href="#cb33-533" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-534"><a href="#cb33-534" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_percentage_matrix(df):</span>
<span id="cb33-535"><a href="#cb33-535" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get unique values of party_A and party_B</span></span>
<span id="cb33-536"><a href="#cb33-536" aria-hidden="true" tabindex="-1"></a>    unique_party_A <span class="op">=</span> df[<span class="st">'party_A'</span>].unique()</span>
<span id="cb33-537"><a href="#cb33-537" aria-hidden="true" tabindex="-1"></a>    unique_party_B <span class="op">=</span> df[<span class="st">'party_B'</span>].unique()</span>
<span id="cb33-538"><a href="#cb33-538" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-539"><a href="#cb33-539" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>unique_party_A, columns<span class="op">=</span>unique_party_A)</span>
<span id="cb33-540"><a href="#cb33-540" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-541"><a href="#cb33-541" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> party_A <span class="kw">in</span> unique_party_A:</span>
<span id="cb33-542"><a href="#cb33-542" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> party_B <span class="kw">in</span> unique_party_A:</span>
<span id="cb33-543"><a href="#cb33-543" aria-hidden="true" tabindex="-1"></a>            subset_df <span class="op">=</span> df[(df[<span class="st">'party_A'</span>] <span class="op">==</span> party_A) <span class="op">&amp;</span> (df[<span class="st">'party_B'</span>] <span class="op">==</span> party_B)]</span>
<span id="cb33-544"><a href="#cb33-544" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> subset_df.empty:</span>
<span id="cb33-545"><a href="#cb33-545" aria-hidden="true" tabindex="-1"></a>                average_percentage <span class="op">=</span> subset_df[<span class="st">'Average_percentage'</span>].values[<span class="dv">0</span>] </span>
<span id="cb33-546"><a href="#cb33-546" aria-hidden="true" tabindex="-1"></a>                matrix.loc[party_A, party_B] <span class="op">=</span> average_percentage</span>
<span id="cb33-547"><a href="#cb33-547" aria-hidden="true" tabindex="-1"></a>    matrix.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-548"><a href="#cb33-548" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mirror the lower triangle to the upper triangle</span></span>
<span id="cb33-549"><a href="#cb33-549" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(matrix)):</span>
<span id="cb33-550"><a href="#cb33-550" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb33-551"><a href="#cb33-551" aria-hidden="true" tabindex="-1"></a>            matrix.iloc[i, j] <span class="op">=</span> matrix.iloc[j, i]</span>
<span id="cb33-552"><a href="#cb33-552" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-553"><a href="#cb33-553" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix</span>
<span id="cb33-554"><a href="#cb33-554" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"This gives a Upper truangular matrix or Right trainagular, so I mirrowed the lower traingular matrix to the upper triangular to get a full symmetrix matrix"</span>)</span>
<span id="cb33-555"><a href="#cb33-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-556"><a href="#cb33-556" aria-hidden="true" tabindex="-1"></a><span class="co"># Call the function with your DataFrame</span></span>
<span id="cb33-557"><a href="#cb33-557" aria-hidden="true" tabindex="-1"></a>matrix_bre_2011 <span class="op">=</span> create_percentage_matrix(df_2011_party_percentages)</span>
<span id="cb33-558"><a href="#cb33-558" aria-hidden="true" tabindex="-1"></a>matrix_bre_2015 <span class="op">=</span> create_percentage_matrix(df_2015_party_percentages)</span>
<span id="cb33-559"><a href="#cb33-559" aria-hidden="true" tabindex="-1"></a>matrix_bre_2019 <span class="op">=</span> create_percentage_matrix(df_2019_party_percentages)</span>
<span id="cb33-560"><a href="#cb33-560" aria-hidden="true" tabindex="-1"></a>matrix_bre_2023 <span class="op">=</span> create_percentage_matrix(df_2023_party_percentages)</span>
<span id="cb33-561"><a href="#cb33-561" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tabulate(matrix_bre_2011, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>))</span>
<span id="cb33-562"><a href="#cb33-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-563"><a href="#cb33-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-564"><a href="#cb33-564" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-565"><a href="#cb33-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-566"><a href="#cb33-566" aria-hidden="true" tabindex="-1"></a>**Union-to-Intersection Ratio Matrix**</span>
<span id="cb33-567"><a href="#cb33-567" aria-hidden="true" tabindex="-1"></a>The second approach involved calculating the ratio of the union to the intersection of co-voters for each pair of political parties. This ratio captures the relative breadth and exclusivity of party support. Specifically, the union represents the total number of unique voters for either party, while the intersection denotes the number of voters who supported both parties.</span>
<span id="cb33-568"><a href="#cb33-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-569"><a href="#cb33-569" aria-hidden="true" tabindex="-1"></a>Mathematically, this ratio is defined as:</span>
<span id="cb33-570"><a href="#cb33-570" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb33-571"><a href="#cb33-571" aria-hidden="true" tabindex="-1"></a>Union-to-Intersection Ratio = \frac{∣Union  of  co-voters∣}{∣Intersection  of  co-voters∣} </span>
<span id="cb33-572"><a href="#cb33-572" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb33-573"><a href="#cb33-573" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb33-574"><a href="#cb33-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-575"><a href="#cb33-575" aria-hidden="true" tabindex="-1"></a>A higher ratio indicates that while there is some overlap in voter bases, each party also attracts a significant number of unique voters. This can highlight distinct but occasionally intersecting political constituencies. In contrast, a lower ratio suggests a stronger mutual reliance on the same voter base, indicating a closer relationship or similarity between the parties.</span>
<span id="cb33-576"><a href="#cb33-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-577"><a href="#cb33-577" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-578"><a href="#cb33-578" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------------------------</span></span>
<span id="cb33-579"><a href="#cb33-579" aria-hidden="true" tabindex="-1"></a><span class="co"># get function to create a matrix for the ration of the common voters to all voter</span></span>
<span id="cb33-580"><a href="#cb33-580" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------- </span></span>
<span id="cb33-581"><a href="#cb33-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-582"><a href="#cb33-582" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_votes_for_pairs(df):</span>
<span id="cb33-583"><a href="#cb33-583" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.applymap(<span class="bu">int</span>)</span>
<span id="cb33-584"><a href="#cb33-584" aria-hidden="true" tabindex="-1"></a>    pair_counter <span class="op">=</span> Counter()</span>
<span id="cb33-585"><a href="#cb33-585" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'party_a_intersection_party_b'</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb33-586"><a href="#cb33-586" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'party_a_union_party_b'</span>] <span class="op">=</span> <span class="dv">0</span> </span>
<span id="cb33-587"><a href="#cb33-587" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb33-588"><a href="#cb33-588" aria-hidden="true" tabindex="-1"></a>        row_values <span class="op">=</span> [(x <span class="op">//</span> <span class="dv">100</span>) <span class="op">*</span> <span class="dv">100</span> <span class="cf">for</span> x <span class="kw">in</span> row <span class="cf">if</span> x<span class="op">!=</span> <span class="dv">0</span>]   </span>
<span id="cb33-589"><a href="#cb33-589" aria-hidden="true" tabindex="-1"></a>        unique_pairs <span class="op">=</span> <span class="bu">set</span>(combinations(row_values, <span class="dv">2</span>)) </span>
<span id="cb33-590"><a href="#cb33-590" aria-hidden="true" tabindex="-1"></a>        pair_counter.update(unique_pairs)   </span>
<span id="cb33-591"><a href="#cb33-591" aria-hidden="true" tabindex="-1"></a>    pair_counts_df <span class="op">=</span> pd.DataFrame(pair_counter.items(), columns<span class="op">=</span>[<span class="st">'Pair'</span>, <span class="st">'Count'</span>])  </span>
<span id="cb33-592"><a href="#cb33-592" aria-hidden="true" tabindex="-1"></a>    pair_counts_df[[<span class="st">'Party_Code_A'</span>, <span class="st">'Party_Code_B'</span>]] <span class="op">=</span> pd.DataFrame(pair_counts_df[<span class="st">'Pair'</span>].tolist())</span>
<span id="cb33-593"><a href="#cb33-593" aria-hidden="true" tabindex="-1"></a>    <span class="co">#pair_counts_df = pair_counts_df[['Party_Code_A', 'Party_Code_B', 'Count']]</span></span>
<span id="cb33-594"><a href="#cb33-594" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over each row in the DataFrame</span></span>
<span id="cb33-595"><a href="#cb33-595" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb33-596"><a href="#cb33-596" aria-hidden="true" tabindex="-1"></a>        party_a <span class="op">=</span> row[<span class="st">'Party_Code_A'</span>]</span>
<span id="cb33-597"><a href="#cb33-597" aria-hidden="true" tabindex="-1"></a>        party_b <span class="op">=</span> row[<span class="st">'Party_Code_B'</span>]</span>
<span id="cb33-598"><a href="#cb33-598" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-599"><a href="#cb33-599" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Count votes for both parties and votes for either party</span></span>
<span id="cb33-600"><a href="#cb33-600" aria-hidden="true" tabindex="-1"></a>        votes_for_both <span class="op">=</span> df[(df[<span class="st">'Party_Code_A'</span>] <span class="op">==</span> party_a) <span class="op">&amp;</span> (df[<span class="st">'Party_Code_B'</span>] <span class="op">==</span> party_b)][<span class="st">'Count'</span>].<span class="bu">sum</span>()</span>
<span id="cb33-601"><a href="#cb33-601" aria-hidden="true" tabindex="-1"></a>        votes_for_either <span class="op">=</span> df[(df[<span class="st">'Party_Code_A'</span>] <span class="op">==</span> party_a) <span class="op">|</span> (df[<span class="st">'Party_Code_B'</span>] <span class="op">==</span> party_b)][<span class="st">'Count'</span>].<span class="bu">sum</span>()</span>
<span id="cb33-602"><a href="#cb33-602" aria-hidden="true" tabindex="-1"></a>        ratio_f <span class="op">=</span> (votes_for_both <span class="op">/</span> votes_for_either).<span class="bu">round</span>(<span class="dv">2</span>)</span>
<span id="cb33-603"><a href="#cb33-603" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the new columns with counts</span></span>
<span id="cb33-604"><a href="#cb33-604" aria-hidden="true" tabindex="-1"></a>        df.loc[index, <span class="st">'party_a_intersection_party_b'</span>] <span class="op">=</span> votes_for_both</span>
<span id="cb33-605"><a href="#cb33-605" aria-hidden="true" tabindex="-1"></a>        df.loc[index, <span class="st">'party_a_union_party_b'</span>] <span class="op">=</span> votes_for_either</span>
<span id="cb33-606"><a href="#cb33-606" aria-hidden="true" tabindex="-1"></a>        df.loc[index, <span class="st">'party_votes_ratio'</span>] <span class="op">=</span> ratio_f</span>
<span id="cb33-607"><a href="#cb33-607" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb33-608"><a href="#cb33-608" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb33-609"><a href="#cb33-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-610"><a href="#cb33-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-611"><a href="#cb33-611" aria-hidden="true" tabindex="-1"></a>df_2011_pair_union <span class="op">=</span> count_votes_for_pairs(df_2011_pair)</span>
<span id="cb33-612"><a href="#cb33-612" aria-hidden="true" tabindex="-1"></a>df_2015_pair_union <span class="op">=</span> count_votes_for_pairs(df_2015_pair)</span>
<span id="cb33-613"><a href="#cb33-613" aria-hidden="true" tabindex="-1"></a>df_2019_pair_union <span class="op">=</span> count_votes_for_pairs(df_2019_pair)</span>
<span id="cb33-614"><a href="#cb33-614" aria-hidden="true" tabindex="-1"></a>df_2023_pair_union <span class="op">=</span> count_votes_for_pairs(df_2023_pair)</span>
<span id="cb33-615"><a href="#cb33-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-616"><a href="#cb33-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-617"><a href="#cb33-617" aria-hidden="true" tabindex="-1"></a>df_2011_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2011_pair_union, party_codes_2011)</span>
<span id="cb33-618"><a href="#cb33-618" aria-hidden="true" tabindex="-1"></a>df_2015_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2015_pair_union, party_codes_2015)</span>
<span id="cb33-619"><a href="#cb33-619" aria-hidden="true" tabindex="-1"></a>df_2019_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2019_pair_union, party_codes_2019)</span>
<span id="cb33-620"><a href="#cb33-620" aria-hidden="true" tabindex="-1"></a>df_2023_party_pairs_ratio <span class="op">=</span> merge_and_clean(df_2023_pair_union, party_codes_2023)</span>
<span id="cb33-621"><a href="#cb33-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-622"><a href="#cb33-622" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_ratio_matrix(df):</span>
<span id="cb33-623"><a href="#cb33-623" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get unique values of party_A and party_B</span></span>
<span id="cb33-624"><a href="#cb33-624" aria-hidden="true" tabindex="-1"></a>    unique_party_A <span class="op">=</span> df[<span class="st">'party_A'</span>].unique()</span>
<span id="cb33-625"><a href="#cb33-625" aria-hidden="true" tabindex="-1"></a>    unique_party_B <span class="op">=</span> df[<span class="st">'party_B'</span>].unique()</span>
<span id="cb33-626"><a href="#cb33-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-627"><a href="#cb33-627" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>unique_party_A, columns<span class="op">=</span>unique_party_B)</span>
<span id="cb33-628"><a href="#cb33-628" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-629"><a href="#cb33-629" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over each unique pair of parties and fill in the matrix with the average percentage</span></span>
<span id="cb33-630"><a href="#cb33-630" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> party_A <span class="kw">in</span> unique_party_A:</span>
<span id="cb33-631"><a href="#cb33-631" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> party_B <span class="kw">in</span> unique_party_B:</span>
<span id="cb33-632"><a href="#cb33-632" aria-hidden="true" tabindex="-1"></a>            subset_df <span class="op">=</span> df[(df[<span class="st">'party_A'</span>] <span class="op">==</span> party_A) <span class="op">&amp;</span> (df[<span class="st">'party_B'</span>] <span class="op">==</span> party_B)]</span>
<span id="cb33-633"><a href="#cb33-633" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> subset_df.empty:</span>
<span id="cb33-634"><a href="#cb33-634" aria-hidden="true" tabindex="-1"></a>                voter_ratio <span class="op">=</span> subset_df[<span class="st">'party_votes_ratio'</span>].values[<span class="dv">0</span>]   </span>
<span id="cb33-635"><a href="#cb33-635" aria-hidden="true" tabindex="-1"></a>                matrix.loc[party_A, party_B] <span class="op">=</span> voter_ratio</span>
<span id="cb33-636"><a href="#cb33-636" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-637"><a href="#cb33-637" aria-hidden="true" tabindex="-1"></a>    matrix.fillna(<span class="dv">0</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-638"><a href="#cb33-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-639"><a href="#cb33-639" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mirror the lower triangle to the upper triangle</span></span>
<span id="cb33-640"><a href="#cb33-640" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(matrix)):</span>
<span id="cb33-641"><a href="#cb33-641" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb33-642"><a href="#cb33-642" aria-hidden="true" tabindex="-1"></a>            matrix.iloc[i, j] <span class="op">=</span> matrix.iloc[j, i]</span>
<span id="cb33-643"><a href="#cb33-643" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-644"><a href="#cb33-644" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix</span>
<span id="cb33-645"><a href="#cb33-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-646"><a href="#cb33-646" aria-hidden="true" tabindex="-1"></a>matrix_bre_2011_ratio <span class="op">=</span> create_ratio_matrix(df_2011_party_pairs_ratio)</span>
<span id="cb33-647"><a href="#cb33-647" aria-hidden="true" tabindex="-1"></a>matrix_bre_2015_ratio <span class="op">=</span> create_ratio_matrix(df_2015_party_pairs_ratio)</span>
<span id="cb33-648"><a href="#cb33-648" aria-hidden="true" tabindex="-1"></a>matrix_bre_2019_ratio <span class="op">=</span> create_ratio_matrix(df_2019_party_pairs_ratio)</span>
<span id="cb33-649"><a href="#cb33-649" aria-hidden="true" tabindex="-1"></a>matrix_bre_2023_ratio <span class="op">=</span> create_ratio_matrix(df_2023_party_pairs_ratio) </span>
<span id="cb33-650"><a href="#cb33-650" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tabulate(matrix_bre_2011_ratio, headers<span class="op">=</span><span class="st">'keys'</span>, tablefmt<span class="op">=</span><span class="st">'grid'</span>))</span>
<span id="cb33-651"><a href="#cb33-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-652"><a href="#cb33-652" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-653"><a href="#cb33-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-654"><a href="#cb33-654" aria-hidden="true" tabindex="-1"></a><span class="fu">## Techniques</span></span>
<span id="cb33-655"><a href="#cb33-655" aria-hidden="true" tabindex="-1"></a><span class="fu">## Dimensionality Reduction</span></span>
<span id="cb33-656"><a href="#cb33-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-657"><a href="#cb33-657" aria-hidden="true" tabindex="-1"></a>**Dimension reduction** refers to a set of techniques which can transform high-dimensional data into their representative low-dimensional data. During the process, some information of the original data is discarded but some main characteristics of the original data is preserved.</span>
<span id="cb33-658"><a href="#cb33-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-659"><a href="#cb33-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-660"><a href="#cb33-660" aria-hidden="true" tabindex="-1"></a>Three dimension reduction techniques:</span>
<span id="cb33-661"><a href="#cb33-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-662"><a href="#cb33-662" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Principal Component Analysis (PCA)** - PCA tries to project the original high-dimensional data into lower dimensions by capturing the most prominent variance in the data. It is a linear combination that projects the data lower component with respect to relative variance</span>
<span id="cb33-663"><a href="#cb33-663" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-664"><a href="#cb33-664" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Multidimensional Scaling (MDS)** - MDS is a technique for reducing data dimensions while attempting to preserve the relative distance between high-dimensional data points. It keeps the relative distances proportional</span>
<span id="cb33-665"><a href="#cb33-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-666"><a href="#cb33-666" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Stochastic Neighbor Embedding (SNE)** - SNE is a non-linear technique to “cluster" data points by trying to keep similar data points close to each other.</span>
<span id="cb33-667"><a href="#cb33-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-668"><a href="#cb33-668" aria-hidden="true" tabindex="-1"></a><span class="fu">### Principal Component Analysis</span></span>
<span id="cb33-669"><a href="#cb33-669" aria-hidden="true" tabindex="-1"></a>*Principal component analysis (PCA)* is often used to find a low dimensional representation of data that maximizes the spread of the projected data.</span>
<span id="cb33-670"><a href="#cb33-670" aria-hidden="true" tabindex="-1"></a>The first principal component is the direction of the largest variance of the data. The second principal component  is perpendicular to the first principal component and is the direction of the largest variance of the data among all directions that are perpendicular to the first principal component. The third principal component () is perpendicular to both first and second principal components and is in the direction of the largest variance among all directions that are perpendicular to both the first and second principal components</span>
<span id="cb33-671"><a href="#cb33-671" aria-hidden="true" tabindex="-1"></a><span class="al">![](../img/PCA.png)</span>{fig-align="center"}</span>
<span id="cb33-672"><a href="#cb33-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-673"><a href="#cb33-673" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Steps to calculate PCA </span></span>
<span id="cb33-674"><a href="#cb33-674" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**STANDARDIZATION**</span>
<span id="cb33-675"><a href="#cb33-675" aria-hidden="true" tabindex="-1"></a>   This is a standard proceduer in data preparation for any machine learning algorithm, standardizing data simple mean putting the  dataset in a standard range, there by removing or reducing the effects of outliers. </span>
<span id="cb33-676"><a href="#cb33-676" aria-hidden="true" tabindex="-1"></a>   $$</span>
<span id="cb33-677"><a href="#cb33-677" aria-hidden="true" tabindex="-1"></a>   standard value, z = \frac{∣value - mean∣}{Standard deviation} </span>
<span id="cb33-678"><a href="#cb33-678" aria-hidden="true" tabindex="-1"></a>   $$</span>
<span id="cb33-679"><a href="#cb33-679" aria-hidden="true" tabindex="-1"></a>   In the Matrix dataset that we've created in the previous chapter, the data is already standadized; the first matrix is was measured in percentages which was reduced to 0-1 in the matrix and the second matrix was also a ration of intersection to union which is also in the range of 0 and 1. </span>
<span id="cb33-680"><a href="#cb33-680" aria-hidden="true" tabindex="-1"></a>   So for this dataset(matrix) we will convert our marix dataset to a numpy array to ab able to perform the next steps</span>
<span id="cb33-681"><a href="#cb33-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-682"><a href="#cb33-682" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-683"><a href="#cb33-683" aria-hidden="true" tabindex="-1"></a>matrix_array <span class="op">=</span> matrix_bre_2011.to_numpy()</span>
<span id="cb33-684"><a href="#cb33-684" aria-hidden="true" tabindex="-1"></a>matrix_array</span>
<span id="cb33-685"><a href="#cb33-685" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-686"><a href="#cb33-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-687"><a href="#cb33-687" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**COVARIANCE MATRIX COMPUTATION**</span>
<span id="cb33-688"><a href="#cb33-688" aria-hidden="true" tabindex="-1"></a>   The covariance matrix is simply to undestand how the variable of a dataset are varying from the mean with respect to each other</span>
<span id="cb33-689"><a href="#cb33-689" aria-hidden="true" tabindex="-1"></a>   <span class="al">![](../img/cov_matrix.png)</span>{fig-align="center"}</span>
<span id="cb33-690"><a href="#cb33-690" aria-hidden="true" tabindex="-1"></a>   I our matrix, we have the political parties on both side so the corelation matrix will shoe the corelation between each two political parties in the dataset</span>
<span id="cb33-691"><a href="#cb33-691" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb33-692"><a href="#cb33-692" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-693"><a href="#cb33-693" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb33-694"><a href="#cb33-694" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Calculate the covariance matrix, eigenvalues and eigenvectors</span></span>
<span id="cb33-695"><a href="#cb33-695" aria-hidden="true" tabindex="-1"></a>covariance_matrix <span class="op">=</span> np.cov(matrix_array, rowvar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb33-696"><a href="#cb33-696" aria-hidden="true" tabindex="-1"></a>covariance_matrix</span>
<span id="cb33-697"><a href="#cb33-697" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-698"><a href="#cb33-698" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>FEATURE VECTOR (EIGENVALUES &amp; EIGENVECTORS)</span>
<span id="cb33-699"><a href="#cb33-699" aria-hidden="true" tabindex="-1"></a>   EigenVectors and EignValues are the features we need form the covariance matrix in order for us to comput the principal components. The EigneVectors and EigenValues comes in pair, so for an N*N matrix, there are N Eignevector and N Eigenvalues. The Eigenvalue is the maginitude while the  Eigenvectors od the covariance matrix show the direction of the axes with the most variance which translate to the principal component</span>
<span id="cb33-700"><a href="#cb33-700" aria-hidden="true" tabindex="-1"></a>  <span class="al">![](../img/eigenvector_decomposition.png)</span>{fig-align="center"}</span>
<span id="cb33-701"><a href="#cb33-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-702"><a href="#cb33-702" aria-hidden="true" tabindex="-1"></a>   For a square matrix A, an Eigenvector and Eigenvalue make this equation true:</span>
<span id="cb33-703"><a href="#cb33-703" aria-hidden="true" tabindex="-1"></a>    Mathematically,</span>
<span id="cb33-704"><a href="#cb33-704" aria-hidden="true" tabindex="-1"></a>   $$</span>
<span id="cb33-705"><a href="#cb33-705" aria-hidden="true" tabindex="-1"></a>   Av = λv</span>
<span id="cb33-706"><a href="#cb33-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-707"><a href="#cb33-707" aria-hidden="true" tabindex="-1"></a>   Av = λvI ; I is an Identity Matrix</span>
<span id="cb33-708"><a href="#cb33-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-709"><a href="#cb33-709" aria-hidden="true" tabindex="-1"></a>   Av - λvI = 0</span>
<span id="cb33-710"><a href="#cb33-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-711"><a href="#cb33-711" aria-hidden="true" tabindex="-1"></a>   If v is non - zero;</span>
<span id="cb33-712"><a href="#cb33-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-713"><a href="#cb33-713" aria-hidden="true" tabindex="-1"></a>   |A-λI| = 0</span>
<span id="cb33-714"><a href="#cb33-714" aria-hidden="true" tabindex="-1"></a>   $$</span>
<span id="cb33-715"><a href="#cb33-715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-716"><a href="#cb33-716" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo =False}</span></span>
<span id="cb33-717"><a href="#cb33-717" aria-hidden="true" tabindex="-1"></a>eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eig(covariance_matrix)</span>
<span id="cb33-718"><a href="#cb33-718" aria-hidden="true" tabindex="-1"></a><span class="co"># Make a list of (eigenvalue, eigenvector) tuples</span></span>
<span id="cb33-719"><a href="#cb33-719" aria-hidden="true" tabindex="-1"></a>eig_pairs <span class="op">=</span> [(np.<span class="bu">abs</span>(eigenvalues[i]), eigenvectors[:, i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(eigenvalues))]</span>
<span id="cb33-720"><a href="#cb33-720" aria-hidden="true" tabindex="-1"></a>eig_pairs.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-721"><a href="#cb33-721" aria-hidden="true" tabindex="-1"></a>eig_pairs[<span class="dv">0</span>]</span>
<span id="cb33-722"><a href="#cb33-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-723"><a href="#cb33-723" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-724"><a href="#cb33-724" aria-hidden="true" tabindex="-1"></a>The first Principal Component is the EigenVector corresponding to the highest Eigen values, and the second component is the second eigenvectore and so on. so now that we've attain out component, we will go ahead and visual them</span>
<span id="cb33-725"><a href="#cb33-725" aria-hidden="true" tabindex="-1"></a><span class="fu"># RESULTS</span></span>
<span id="cb33-726"><a href="#cb33-726" aria-hidden="true" tabindex="-1"></a><span class="fu">## PCA</span></span>
<span id="cb33-727"><a href="#cb33-727" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo= FALSE} </span></span>
<span id="cb33-728"><a href="#cb33-728" aria-hidden="true" tabindex="-1"></a><span class="co">#---------------------------------</span></span>
<span id="cb33-729"><a href="#cb33-729" aria-hidden="true" tabindex="-1"></a><span class="co"># Party names, labels, total votes, and colors for the visualization</span></span>
<span id="cb33-730"><a href="#cb33-730" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------</span></span>
<span id="cb33-731"><a href="#cb33-731" aria-hidden="true" tabindex="-1"></a>bremen_2011_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2011_party_percentages.pkl"</span>)</span>
<span id="cb33-732"><a href="#cb33-732" aria-hidden="true" tabindex="-1"></a>bre_2011_label_votes <span class="op">=</span> bremen_2011_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb33-733"><a href="#cb33-733" aria-hidden="true" tabindex="-1"></a>bremen_2015_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2015_party_percentages.pkl"</span>)</span>
<span id="cb33-734"><a href="#cb33-734" aria-hidden="true" tabindex="-1"></a>bre_2015_label_votes <span class="op">=</span> bremen_2015_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb33-735"><a href="#cb33-735" aria-hidden="true" tabindex="-1"></a>bremen_2019_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2019_party_percentages.pkl"</span>)</span>
<span id="cb33-736"><a href="#cb33-736" aria-hidden="true" tabindex="-1"></a>bre_2019_label_votes <span class="op">=</span> bremen_2019_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb33-737"><a href="#cb33-737" aria-hidden="true" tabindex="-1"></a>bremen_2023_percent <span class="op">=</span> pd.read_pickle(<span class="st">"../Data/prepared_date/bremen_2023_party_percentages.pkl"</span>)</span>
<span id="cb33-738"><a href="#cb33-738" aria-hidden="true" tabindex="-1"></a>bre_2023_label_votes <span class="op">=</span> bremen_2023_percent[[<span class="st">'Kurzform'</span>, <span class="st">'total_count'</span>, <span class="st">'Colour'</span>]]</span>
<span id="cb33-739"><a href="#cb33-739" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-740"><a href="#cb33-740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-741"><a href="#cb33-741" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-742"><a href="#cb33-742" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perform_pca_new(matrix_df, labels_df, n_components<span class="op">=</span><span class="dv">2</span>, title<span class="op">=</span><span class="st">'PCA Result'</span>):</span>
<span id="cb33-743"><a href="#cb33-743" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert dataframe to NumPy array</span></span>
<span id="cb33-744"><a href="#cb33-744" aria-hidden="true" tabindex="-1"></a>    matrix_array <span class="op">=</span> matrix_df.to_numpy()</span>
<span id="cb33-745"><a href="#cb33-745" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-746"><a href="#cb33-746" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the covariance matrix</span></span>
<span id="cb33-747"><a href="#cb33-747" aria-hidden="true" tabindex="-1"></a>    covariance_matrix <span class="op">=</span> np.cov(matrix_array, rowvar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb33-748"><a href="#cb33-748" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-749"><a href="#cb33-749" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute eigenvalues and eigenvectors</span></span>
<span id="cb33-750"><a href="#cb33-750" aria-hidden="true" tabindex="-1"></a>    eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eig(covariance_matrix)</span>
<span id="cb33-751"><a href="#cb33-751" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-752"><a href="#cb33-752" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort eigenvectors based on eigenvalues</span></span>
<span id="cb33-753"><a href="#cb33-753" aria-hidden="true" tabindex="-1"></a>    sorted_indices <span class="op">=</span> np.argsort(eigenvalues)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb33-754"><a href="#cb33-754" aria-hidden="true" tabindex="-1"></a>    topk_indices <span class="op">=</span> sorted_indices[:n_components]</span>
<span id="cb33-755"><a href="#cb33-755" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-756"><a href="#cb33-756" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select the top-k eigenvectors</span></span>
<span id="cb33-757"><a href="#cb33-757" aria-hidden="true" tabindex="-1"></a>    selected_eigenvectors <span class="op">=</span> eigenvectors[:, topk_indices]</span>
<span id="cb33-758"><a href="#cb33-758" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-759"><a href="#cb33-759" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract labels and sizes from the labels DataFrame</span></span>
<span id="cb33-760"><a href="#cb33-760" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels_df[<span class="st">'Kurzform'</span>].tolist()</span>
<span id="cb33-761"><a href="#cb33-761" aria-hidden="true" tabindex="-1"></a>    sizes <span class="op">=</span> np.sqrt(labels_df[<span class="st">'total_count'</span>]).tolist() </span>
<span id="cb33-762"><a href="#cb33-762" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> labels_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>).tolist()  <span class="co"># Replace NaN with 'grey'</span></span>
<span id="cb33-763"><a href="#cb33-763" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-764"><a href="#cb33-764" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot PCA result with adjusted point sizes and labels</span></span>
<span id="cb33-765"><a href="#cb33-765" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb33-766"><a href="#cb33-766" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (label, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(labels, colors)):</span>
<span id="cb33-767"><a href="#cb33-767" aria-hidden="true" tabindex="-1"></a>        plt.scatter(eigenvectors[i, <span class="dv">0</span>], eigenvectors[i, <span class="dv">1</span>], s<span class="op">=</span>sizes[i], color<span class="op">=</span>color)</span>
<span id="cb33-768"><a href="#cb33-768" aria-hidden="true" tabindex="-1"></a>        plt.annotate(label, (eigenvectors[i, <span class="dv">0</span>], eigenvectors[i, <span class="dv">1</span>]))</span>
<span id="cb33-769"><a href="#cb33-769" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-770"><a href="#cb33-770" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot PCA result</span></span>
<span id="cb33-771"><a href="#cb33-771" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plt.scatter(eigenvectors[:, 0], eigenvectors[:, 1])</span></span>
<span id="cb33-772"><a href="#cb33-772" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb33-773"><a href="#cb33-773" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Principal Component 1'</span>)</span>
<span id="cb33-774"><a href="#cb33-774" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Principal Component 2'</span>)</span>
<span id="cb33-775"><a href="#cb33-775" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb33-776"><a href="#cb33-776" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb33-777"><a href="#cb33-777" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb33-778"><a href="#cb33-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-779"><a href="#cb33-779" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot each PCA result</span></span>
<span id="cb33-780"><a href="#cb33-780" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2011, bre_2011_label_votes, title<span class="op">=</span><span class="st">'Bremen 2011 - Average Co-voter percentages'</span>)</span>
<span id="cb33-781"><a href="#cb33-781" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2015, bre_2015_label_votes, title<span class="op">=</span><span class="st">'Bremen 2015 - Average Co-voter percentages'</span>)</span>
<span id="cb33-782"><a href="#cb33-782" aria-hidden="true" tabindex="-1"></a><span class="co">#perform_pca_new(matrix_bre_2019, bre_2019_label_votes, title='Bremen 2019 - Average Co-voter percentages')</span></span>
<span id="cb33-783"><a href="#cb33-783" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2023, bre_2023_label_votes, title<span class="op">=</span><span class="st">'Bremen 2023 - Average Co-voter percentages'</span>)</span>
<span id="cb33-784"><a href="#cb33-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-785"><a href="#cb33-785" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-786"><a href="#cb33-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-787"><a href="#cb33-787" aria-hidden="true" tabindex="-1"></a>In the figues above, I have represent in two dimensions (2D) the first two principal components of the avaerage percentages co-voters showing the display of the political parties thath participated in that year's elections. Since PCA reprensents our data with respect to maximum variance, we deduced that pricipal component one shows the highest variance of between the parties following bay principal component two. In describing political parties, several characteristics can be use such as size of the party, demopharaphics, wing, Geographical base, etc. We will use some of these measure to interpret our figures.</span>
<span id="cb33-788"><a href="#cb33-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-789"><a href="#cb33-789" aria-hidden="true" tabindex="-1"></a>In the first figure, *Bremen 2011 - Average Co-voter percentages*, one can characerize the first principal componet as the wing of the parties as we see alomost a clear distintion of the parties on opposite wings, most notable is the left(Die Linke) which is a popalr far left pary on the far positve end of our x-axis and NPD on the far negative end of the x-axis. The second principal component can be used to describe the size of the parties are we see the biggest parties towards the bottom  and smaller parties above them.</span>
<span id="cb33-790"><a href="#cb33-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-791"><a href="#cb33-791" aria-hidden="true" tabindex="-1"></a>In the Second figure, *Bremen 201 - Average Co-voter percentages*, we can again characerize the first principal componet as the wing of the parties as we see alomost a clear distintion of the parties on opposite wings, most notable is the left(Die Linke) and Grüne which is a popalr far left pary on the far negative end of our x-axis and AFD and BIW on the far positive end of the x-axis, this is in contrast to the first figure where the positve end of the x-axis was the left wing parties and the negative is the right wing parties. The second principal component can be used to describe the size of the parties are we see the biggest parties.</span>
<span id="cb33-792"><a href="#cb33-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-793"><a href="#cb33-793" aria-hidden="true" tabindex="-1"></a>In the third figure, *Bremen 2023 - Average Co-voter percentages*, just like the first one, the first principal componet can be characterized as the wing of the parties as we see alomost a clear distintion of the parties on opposite wings, most notable is the left(Die Linke) which is a popalr far left pary on the far positve end of our x-axis and BIW on the far negative end of the x-axis. The second principal component can be used to describe the popularity of the parties are we see the biggest parties. </span>
<span id="cb33-794"><a href="#cb33-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-795"><a href="#cb33-795" aria-hidden="true" tabindex="-1"></a>Now lets display the principal components of the Ratio between the union and the intersection</span>
<span id="cb33-796"><a href="#cb33-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-799"><a href="#cb33-799" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb33-800"><a href="#cb33-800" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2011_ratio, bre_2011_label_votes, title<span class="op">=</span><span class="st">'Bremen Voter Ratio 2011'</span>)</span>
<span id="cb33-801"><a href="#cb33-801" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2015_ratio, bre_2015_label_votes, title<span class="op">=</span><span class="st">'Bremen Voter Ratio 2015'</span>)</span>
<span id="cb33-802"><a href="#cb33-802" aria-hidden="true" tabindex="-1"></a><span class="co">#perform_pca_new(matrix_bre_2019_ratio, bre_2019_label_votes, title='Bremen Voter Ratio 2019')</span></span>
<span id="cb33-803"><a href="#cb33-803" aria-hidden="true" tabindex="-1"></a>perform_pca_new(matrix_bre_2023_ratio, bre_2023_label_votes, title<span class="op">=</span><span class="st">'Bremen Voter Ratio 2023'</span>)</span>
<span id="cb33-804"><a href="#cb33-804" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-805"><a href="#cb33-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-806"><a href="#cb33-806" aria-hidden="true" tabindex="-1"></a>The first figure titled *Bremen Voter Ratio 2011* shows an interesting display of paties in 2D. I can see the largest parties like SPD, CDU and GRÜNE clustered around the far positive end of the first principal component, so I can deduce that it reprent the size of the parties. The second component with CDU isolated at the bottom of the chart, one could deduce that this component can describe the demographic appeal of the party be cause  CDU is know for it traditional norms, and voter concentration higher in older people in rural area rather than urban areas unlike SPD wich is in the opposite side of the chart known for being a party of the working class and trade uinions.</span>
<span id="cb33-807"><a href="#cb33-807" aria-hidden="true" tabindex="-1"></a>In the second Figure, *Bremen Voter Ratio 2015* very much similar to the first one, we can describe the forst principle as the size of the political party with the biggest parties like SPD, CDU, GRÜNE and Die Linke all situated on the far right of the first principal component. the second component again can be used to describe the demographic appeal of the party.</span>
<span id="cb33-808"><a href="#cb33-808" aria-hidden="true" tabindex="-1"></a>The third figure has rhe same interpretation as the previous ones.</span>
<span id="cb33-809"><a href="#cb33-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-810"><a href="#cb33-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-811"><a href="#cb33-811" aria-hidden="true" tabindex="-1"></a><span class="fu">## Muti Dimensional Scaling</span></span>
<span id="cb33-812"><a href="#cb33-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-813"><a href="#cb33-813" aria-hidden="true" tabindex="-1"></a>**Multidimensional scaling (MDS)** is a non-linear dimensionality reduction method to extract a lower-dimensional configuration from the measurement of pairwise distances (dissimilarities) between the points in a dataset.</span>
<span id="cb33-814"><a href="#cb33-814" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Steps to calculate MDS</span></span>
<span id="cb33-815"><a href="#cb33-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-816"><a href="#cb33-816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-817"><a href="#cb33-817" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-818"><a href="#cb33-818" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> MDS</span>
<span id="cb33-819"><a href="#cb33-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-820"><a href="#cb33-820" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_mds_with_labels_and_sizes(matrix_df, labels_df, title<span class="op">=</span><span class="st">'MDS Result'</span>):</span>
<span id="cb33-821"><a href="#cb33-821" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert dataframe to NumPy array and scale it</span></span>
<span id="cb33-822"><a href="#cb33-822" aria-hidden="true" tabindex="-1"></a>    matrix_array <span class="op">=</span> matrix_df.to_numpy()</span>
<span id="cb33-823"><a href="#cb33-823" aria-hidden="true" tabindex="-1"></a>   <span class="co"># matrix_array = scale(matrix_array)</span></span>
<span id="cb33-824"><a href="#cb33-824" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-825"><a href="#cb33-825" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform MDS</span></span>
<span id="cb33-826"><a href="#cb33-826" aria-hidden="true" tabindex="-1"></a>    mds <span class="op">=</span> MDS(n_components<span class="op">=</span><span class="dv">2</span>, dissimilarity<span class="op">=</span><span class="st">'precomputed'</span>)</span>
<span id="cb33-827"><a href="#cb33-827" aria-hidden="true" tabindex="-1"></a>    mds_result <span class="op">=</span> mds.fit_transform(matrix_array)</span>
<span id="cb33-828"><a href="#cb33-828" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-829"><a href="#cb33-829" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract labels, sizes, and colors from the labels DataFrame</span></span>
<span id="cb33-830"><a href="#cb33-830" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels_df[<span class="st">'Kurzform'</span>].tolist()</span>
<span id="cb33-831"><a href="#cb33-831" aria-hidden="true" tabindex="-1"></a>    sizes <span class="op">=</span> np.sqrt(labels_df[<span class="st">'total_count'</span>]).tolist()</span>
<span id="cb33-832"><a href="#cb33-832" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> labels_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>).tolist()  <span class="co"># Replace NaN with 'grey'</span></span>
<span id="cb33-833"><a href="#cb33-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-834"><a href="#cb33-834" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot MDS result with adjusted point sizes and colors</span></span>
<span id="cb33-835"><a href="#cb33-835" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb33-836"><a href="#cb33-836" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (label, size, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(labels, sizes, colors)):</span>
<span id="cb33-837"><a href="#cb33-837" aria-hidden="true" tabindex="-1"></a>        plt.scatter(mds_result[i, <span class="dv">0</span>], mds_result[i, <span class="dv">1</span>], s<span class="op">=</span>size, color<span class="op">=</span>color)</span>
<span id="cb33-838"><a href="#cb33-838" aria-hidden="true" tabindex="-1"></a>        plt.annotate(label, (mds_result[i, <span class="dv">0</span>], mds_result[i, <span class="dv">1</span>]))</span>
<span id="cb33-839"><a href="#cb33-839" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-840"><a href="#cb33-840" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set plot title and labels</span></span>
<span id="cb33-841"><a href="#cb33-841" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb33-842"><a href="#cb33-842" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'MDS Dimension 1'</span>)</span>
<span id="cb33-843"><a href="#cb33-843" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'MDS Dimension 2'</span>)</span>
<span id="cb33-844"><a href="#cb33-844" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-845"><a href="#cb33-845" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show plot</span></span>
<span id="cb33-846"><a href="#cb33-846" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb33-847"><a href="#cb33-847" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb33-848"><a href="#cb33-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-849"><a href="#cb33-849" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2011, bre_2011_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2011'</span>)</span>
<span id="cb33-850"><a href="#cb33-850" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2015, bre_2015_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2015'</span>)</span>
<span id="cb33-851"><a href="#cb33-851" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2019, bre_2019_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2019'</span>)</span>
<span id="cb33-852"><a href="#cb33-852" aria-hidden="true" tabindex="-1"></a>plot_mds_with_labels_and_sizes(matrix_bre_2023, bre_2023_label_votes, title<span class="op">=</span><span class="st">'MDS Bremen 2023'</span>)</span>
<span id="cb33-853"><a href="#cb33-853" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-854"><a href="#cb33-854" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Interpretaion of the figures</span></span>
<span id="cb33-855"><a href="#cb33-855" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-856"><a href="#cb33-856" aria-hidden="true" tabindex="-1"></a><span class="fu">## TSNE</span></span>
<span id="cb33-857"><a href="#cb33-857" aria-hidden="true" tabindex="-1"></a>**Stochastic neighbor embedding (SNE)** is a probabilistic approach to dimensional reduction that places data points in high dimensional space into low dimensional space while preserving the identity of neighbors. That is, SNE attempts to keep nearby data points nearby, and separated data points relatively far apart. </span>
<span id="cb33-858"><a href="#cb33-858" aria-hidden="true" tabindex="-1"></a>It tries to keep the data clusters together but relative distance/ arrangement of different clusters can change.</span>
<span id="cb33-859"><a href="#cb33-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-860"><a href="#cb33-860" aria-hidden="true" tabindex="-1"></a>Gaussian distribution is applied to each data point in P and Q subspace</span>
<span id="cb33-861"><a href="#cb33-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-862"><a href="#cb33-862" aria-hidden="true" tabindex="-1"></a><span class="in">```{python, echo=FALSE}</span></span>
<span id="cb33-863"><a href="#cb33-863" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb33-864"><a href="#cb33-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-865"><a href="#cb33-865" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perform_and_plot_tsne(matrix_df, labels_df,labels<span class="op">=</span><span class="va">None</span>, random_state<span class="op">=</span><span class="dv">0</span>, n_components<span class="op">=</span><span class="dv">2</span>, perplexity<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb33-866"><a href="#cb33-866" aria-hidden="true" tabindex="-1"></a>                          learning_rate<span class="op">=</span><span class="st">"auto"</span>, title<span class="op">=</span><span class="st">'t-SNE Result'</span>):</span>
<span id="cb33-867"><a href="#cb33-867" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert dataframe to NumPy array</span></span>
<span id="cb33-868"><a href="#cb33-868" aria-hidden="true" tabindex="-1"></a>    matrix_array <span class="op">=</span> matrix_df.to_numpy()</span>
<span id="cb33-869"><a href="#cb33-869" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-870"><a href="#cb33-870" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform t-SNE</span></span>
<span id="cb33-871"><a href="#cb33-871" aria-hidden="true" tabindex="-1"></a>    tsne <span class="op">=</span> TSNE(n_components<span class="op">=</span>n_components, perplexity<span class="op">=</span>perplexity, learning_rate<span class="op">=</span>learning_rate, random_state<span class="op">=</span>random_state)</span>
<span id="cb33-872"><a href="#cb33-872" aria-hidden="true" tabindex="-1"></a>    tsne_result <span class="op">=</span> tsne.fit_transform(matrix_array)</span>
<span id="cb33-873"><a href="#cb33-873" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-874"><a href="#cb33-874" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract labels, sizes, and colors from the labels DataFrame</span></span>
<span id="cb33-875"><a href="#cb33-875" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels_df[<span class="st">'Kurzform'</span>].tolist()</span>
<span id="cb33-876"><a href="#cb33-876" aria-hidden="true" tabindex="-1"></a>    sizes <span class="op">=</span> np.sqrt(labels_df[<span class="st">'total_count'</span>]).tolist()</span>
<span id="cb33-877"><a href="#cb33-877" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> labels_df[<span class="st">'Colour'</span>].fillna(<span class="st">'grey'</span>).tolist()  <span class="co"># Replace NaN with 'grey'</span></span>
<span id="cb33-878"><a href="#cb33-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-879"><a href="#cb33-879" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot MDS result with adjusted point sizes and colors</span></span>
<span id="cb33-880"><a href="#cb33-880" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb33-881"><a href="#cb33-881" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (label, size, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(labels, sizes, colors)):</span>
<span id="cb33-882"><a href="#cb33-882" aria-hidden="true" tabindex="-1"></a>        plt.scatter(tsne_result[i, <span class="dv">0</span>], tsne_result[i, <span class="dv">1</span>], s<span class="op">=</span>size, color<span class="op">=</span>color)</span>
<span id="cb33-883"><a href="#cb33-883" aria-hidden="true" tabindex="-1"></a>        plt.annotate(label, (tsne_result[i, <span class="dv">0</span>], tsne_result[i, <span class="dv">1</span>]))</span>
<span id="cb33-884"><a href="#cb33-884" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-885"><a href="#cb33-885" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb33-886"><a href="#cb33-886" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Component 1'</span>)</span>
<span id="cb33-887"><a href="#cb33-887" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Component 2'</span>)</span>
<span id="cb33-888"><a href="#cb33-888" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb33-889"><a href="#cb33-889" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb33-890"><a href="#cb33-890" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb33-891"><a href="#cb33-891" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-892"><a href="#cb33-892" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb33-893"><a href="#cb33-893" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2011, bre_2011_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2011'</span>)</span>
<span id="cb33-894"><a href="#cb33-894" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2015, bre_2015_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2015'</span>)</span>
<span id="cb33-895"><a href="#cb33-895" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2019, bre_2019_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2019'</span>)</span>
<span id="cb33-896"><a href="#cb33-896" aria-hidden="true" tabindex="-1"></a>perform_and_plot_tsne(matrix_bre_2023, bre_2023_label_votes, title<span class="op">=</span><span class="st">'TSNE on average percent - Bre 2023'</span>)</span>
<span id="cb33-897"><a href="#cb33-897" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb33-898"><a href="#cb33-898" aria-hidden="true" tabindex="-1"></a><span class="fu"># Discusion</span></span>
<span id="cb33-899"><a href="#cb33-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-900"><a href="#cb33-900" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-901"><a href="#cb33-901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-902"><a href="#cb33-902" aria-hidden="true" tabindex="-1"></a><span class="fu"># REFERENCES</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>